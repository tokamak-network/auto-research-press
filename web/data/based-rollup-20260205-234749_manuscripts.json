{
  "manuscript_v2": "# Based Rollups: A Comprehensive Research Report on Ethereum-Native Sequencing for Layer 2 Scalability\n\n## Executive Summary\n\nBased rollups represent a paradigm shift in Layer 2 (L2) scaling architecture, fundamentally reconceptualizing the relationship between rollups and their underlying Layer 1 (L1) blockchain. Unlike conventional rollup designs that employ centralized or semi-decentralized sequencer networks, based rollups delegate transaction ordering directly to the L1 block proposers\u2014specifically, Ethereum validators in the context of Ethereum-based implementations.\n\nThis architectural decision carries profound implications for security, decentralization, liveness guarantees, and economic alignment within the broader blockchain ecosystem. By eliminating the need for dedicated sequencer infrastructure, based rollups inherit Ethereum's robust decentralization properties while simultaneously addressing critical concerns around censorship resistance and single points of failure that plague existing rollup implementations.\n\nThis report provides a comprehensive technical analysis of based rollups, examining their theoretical foundations, architectural components, economic implications, and practical implementations. We evaluate the trade-offs inherent in this design, compare based rollups against alternative sequencing mechanisms, and assess their potential to reshape the Layer 2 landscape. Our analysis draws upon recent academic literature, protocol specifications, and empirical data from early implementations to present a rigorous assessment of this emerging technology.\n\nKey findings indicate that based rollups offer superior decentralization and censorship resistance properties at the cost of reduced transaction confirmation latency and diminished MEV (Maximal Extractable Value) capture for L2 operators. The technology represents a compelling option for applications prioritizing security and Ethereum alignment over raw performance metrics, though hybrid approaches incorporating preconfirmation mechanisms may ultimately prove most practical for mainstream adoption. Critical challenges remain in preconfirmation standardization, cross-rollup composability, and sustainable economic models for L2 operators.\n\n---\n\n## 1. Introduction\n\n### 1.1 The Rollup Scaling Paradigm\n\nEthereum's transition to a rollup-centric roadmap, formally articulated by Vitalik Buterin in 2020, positioned Layer 2 solutions as the primary mechanism for achieving scalable transaction throughput while preserving the security guarantees of the base layer. Rollups execute transactions off-chain while posting compressed transaction data or state commitments to Ethereum, thereby inheriting its security properties while dramatically reducing per-transaction costs.\n\nThe rollup ecosystem has bifurcated into two primary categories based on their fraud/validity proof mechanisms:\n\n1. **Optimistic Rollups**: Assume transaction validity by default, employing fraud proofs during a challenge period (typically 7 days) to detect and penalize invalid state transitions. Prominent implementations include Optimism, Arbitrum, and Base.\n\n2. **Zero-Knowledge (ZK) Rollups**: Generate cryptographic validity proofs for each batch of transactions, enabling immediate finality upon proof verification. Notable examples include zkSync Era, StarkNet, Polygon zkEVM, and Scroll.\n\n3. **Validiums**: A variant that posts validity proofs to L1 but stores transaction data off-chain, offering higher throughput at the cost of weaker data availability guarantees. StarkEx operates in this mode for certain applications.\n\nBoth rollup categories, however, share a common architectural element that has emerged as a significant centralization vector: the sequencer.\n\n### 1.2 The Sequencer Problem\n\nThe sequencer serves as the entity responsible for ordering transactions within a rollup, constructing blocks, and submitting batched data to the L1. In virtually all production rollup deployments as of 2024, sequencing is performed by a single, centralized operator\u2014typically the rollup development team itself.\n\nThis centralization introduces several concerning properties:\n\n- **Censorship Vulnerability**: A centralized sequencer can selectively exclude transactions, potentially for regulatory compliance, competitive advantage, or malicious purposes.\n- **Liveness Dependency**: Sequencer downtime results in complete rollup unavailability, as demonstrated by multiple incidents affecting Arbitrum and Optimism.\n- **MEV Extraction**: Centralized sequencers capture all MEV generated on the rollup, creating misaligned incentives and potential for user exploitation.\n- **Trust Assumptions**: Users must trust the sequencer to behave honestly, undermining the trustless ethos of blockchain systems.\n\n### 1.3 Defining Based Rollups\n\nThe term \"based rollup\" was formally introduced by Justin Drake of the Ethereum Foundation in March 2023, though the underlying concept had been discussed in various forms previously. Drake's definition provides the canonical characterization:\n\n> \"A rollup is said to be based, or L1-sequenced, when its sequencing is driven by the base L1. More concretely, a based rollup is one where the next L1 proposer may, in collaboration with L1 searchers and builders, permissionlessly include the next rollup block as part of the next L1 block.\"\n\nThis definition establishes three critical properties:\n\n1. **L1 Proposer Authority**: Ethereum validators (proposers) determine rollup block contents.\n2. **Permissionless Participation**: Any L1 proposer can sequence rollup transactions without special permissions.\n3. **Atomic Inclusion**: Rollup blocks are included atomically within L1 blocks.\n\n---\n\n## 2. Technical Architecture\n\n### 2.1 System Components\n\nA based rollup architecture comprises several interconnected components:\n\n#### 2.1.1 L1 Block Proposers and Builders\n\nUnder Ethereum's proof-of-stake consensus with Proposer-Builder Separation (PBS), validators are pseudo-randomly selected to propose blocks, while specialized builders construct block contents. In a based rollup system, builders gain the capability of incorporating rollup batches into their block construction, optimizing across both L1 and L2 transaction inclusion.\n\nThe distinction between proposers and builders is critical: under the MEV-Boost PBS architecture, proposers commit to block headers provided by builders through a relay system, without necessarily knowing the full block contents. This means based rollup batch inclusion occurs at the builder level, with proposers indirectly enabling L2 sequencing through their block commitments.\n\n#### 2.1.2 Based Rollup Nodes\n\nRollup nodes maintain the L2 state and provide transaction execution services. Unlike centralized sequencer architectures, based rollup nodes operate in a more egalitarian manner:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    L1 (Ethereum)                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  Builder 1  \u2502  \u2502  Builder 2  \u2502  \u2502  Builder N  \u2502     \u2502\n\u2502  \u2502 (constructs \u2502  \u2502 (constructs \u2502  \u2502 (constructs \u2502     \u2502\n\u2502  \u2502  L1+L2 txs) \u2502  \u2502  L1+L2 txs) \u2502  \u2502  L1+L2 txs) \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502         \u2502                \u2502                \u2502             \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502   Relay   \u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502 Proposer  \u2502                        \u2502\n\u2502                    \u2502(validator)\u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502 L1 Block  \u2502                        \u2502\n\u2502                    \u2502(+L2 Batch)\u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Based Rollup (L2)                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502   Node 1    \u2502  \u2502   Node 2    \u2502  \u2502   Node N    \u2502     \u2502\n\u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502     \u2502\n\u2502  \u2502   state)    \u2502  \u2502   state)    \u2502  \u2502   state)    \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n#### 2.1.3 Transaction Mempool\n\nBased rollups may utilize either a shared L1 mempool or maintain a separate L2 mempool that L1 builders can access. The mempool architecture significantly impacts MEV dynamics and transaction ordering guarantees. L2-specific mempools require builders to run additional infrastructure or integrate with L2 mempool aggregators, while shared mempools expose L2 transactions to L1 MEV extraction dynamics.\n\n#### 2.1.4 State Derivation Pipeline\n\nAll based rollup nodes derive the canonical L2 state by processing L1 blocks in order, extracting relevant rollup transactions, and executing them deterministically. This derivation process ensures consensus without requiring explicit L2 consensus mechanisms. The derivation pipeline must handle several critical functions detailed in Section 2.5.\n\n### 2.2 Block Production Mechanism\n\nThe block production process in a based rollup follows a distinct workflow:\n\n1. **Transaction Submission**: Users submit transactions to the L2 mempool or directly to L1 builders.\n\n2. **Builder Aggregation**: L1 block builders aggregate both L1 and L2 transactions, optimizing for total extractable value across both layers.\n\n3. **Relay Auction**: Builders submit block bids to relays, which verify block validity and forward winning bids to proposers.\n\n4. **Block Proposal**: The selected L1 proposer commits to a block header containing the L2 batch.\n\n5. **L1 Finalization**: The L1 block achieves finality through Ethereum's Gasper consensus mechanism (approximately 2 epochs, ~12-15 minutes).\n\n6. **L2 State Derivation**: Based rollup nodes process the L1 block, extract L2 transactions, and update the L2 state accordingly.\n\n### 2.3 Data Availability and EIP-4844 Integration\n\nBased rollups must post sufficient data to L1 to enable state reconstruction. With EIP-4844 (Proto-Danksharding), rollups can utilize blob transactions for more cost-effective data availability.\n\n#### 2.3.1 Blob Transaction Economics\n\nEIP-4844 introduces a separate fee market for blob data with distinct economic properties:\n\n- **Blob Gas Pricing**: Blob base fees adjust independently of execution gas, following an exponential mechanism targeting 3 blobs per block (384 KB) with a maximum of 6 blobs (768 KB).\n- **Price Volatility**: Blob fees can spike during high demand periods independently of L1 execution gas costs, requiring rollups to implement dynamic fee strategies.\n- **Cost Comparison**: At target utilization, blob data costs approximately 1-10 gwei per byte versus 16 gwei per byte for calldata, representing 10-100x cost reduction.\n\n```\nBlob Economics (EIP-4844):\n- Target: 3 blobs/block \u00d7 128 KB = 384 KB\n- Maximum: 6 blobs/block \u00d7 128 KB = 768 KB\n- Blob base fee adjustment: \u00b112.5% per block based on utilization\n- Current typical blob fee: 1-50 gwei per blob (highly variable)\n```\n\n#### 2.3.2 Blob Retention and Data Availability\n\nA critical consideration for based rollups is the blob retention window:\n\n- **Retention Period**: Blobs are guaranteed available for 4096 epochs (~18 days) before pruning.\n- **Implications for Optimistic Rollups**: The 7-day challenge period fits within the retention window, but rollups must ensure fraud proof submission occurs before blob pruning.\n- **Historical Reconstruction**: After blob pruning, rollups must maintain their own archival infrastructure or rely on third-party data availability providers (e.g., EthStorage, 0xBlobstore) for historical state reconstruction.\n- **Fallback Mechanisms**: Based rollups should implement calldata fallback when blob space is congested or blob fees spike above threshold levels.\n\n#### 2.3.3 Batch Submission Architecture\n\nBased rollup batches are submitted through the L1 builder pipeline rather than direct proposer submission:\n\n```solidity\n// Based rollup batch structure\nstruct RollupBatch {\n    bytes32 previousStateRoot;\n    bytes32 newStateRoot;\n    bytes32 withdrawalRoot;\n    uint64 l1BlockNumber;\n    bytes32 l1BlockHash;\n    uint64 l2BlockNumber;\n    bytes32 blobVersionedHash; // Reference to blob data\n}\n\n// Batch inbox contract (simplified)\ncontract BatchInbox {\n    event BatchAppended(\n        uint256 indexed batchIndex,\n        bytes32 indexed l1BlockHash,\n        bytes32 stateRoot\n    );\n    \n    function appendBatch(RollupBatch calldata batch) external {\n        // Verify blob data availability via point evaluation precompile\n        require(\n            verifyBlobData(batch.blobVersionedHash),\n            \"Blob data unavailable\"\n        );\n        require(\n            batch.l1BlockHash == blockhash(batch.l1BlockNumber),\n            \"Invalid L1 reference\"\n        );\n        // Note: No msg.sender restriction - permissionless submission\n        // Batch validity determined by derivation rules, not submitter identity\n        emit BatchAppended(nextBatchIndex++, batch.l1BlockHash, batch.newStateRoot);\n    }\n}\n```\n\nThe permissionless nature of batch submission is key: any party can submit batches, with validity determined by derivation rules rather than submitter identity.\n\n### 2.4 Proof Systems\n\nBased rollups can employ either optimistic or validity proof systems, each with specific considerations for the based sequencing model:\n\n#### 2.4.1 Optimistic Based Rollups\n\nFraud proofs in optimistic based rollups face unique challenges:\n\n- **No Canonical Sequencer**: Without a centralized sequencer, fraud proofs challenge the derived state rather than sequencer commitments. The challenge target becomes the batch submitter's bond or a shared security pool.\n- **Derivation Disputes**: Fraud proofs must demonstrate that the claimed state root differs from the correctly derived state given the L1 block contents.\n- **Challenge Period Timing**: The 7-day challenge period must complete before blob data pruning (~18 days), providing adequate margin but requiring monitoring.\n\n```\nOptimistic Based Rollup Fraud Proof Flow:\n1. Batch submitted with state commitment S1\n2. Challenger claims correct state is S2 \u2260 S1\n3. Interactive dispute game bisects execution trace\n4. Single-step proof executed on L1\n5. Loser's bond slashed, winner compensated\n```\n\n#### 2.4.2 ZK Based Rollups\n\nValidity proof generation introduces timing considerations:\n\n- **Proof-Finality Race**: Provers must generate proofs for state transitions derived from L1 blocks that may not yet be finalized. If L1 reorgs occur, proofs may become invalid.\n- **Proof Timing Strategies**:\n  - *Eager proving*: Generate proofs immediately, accept reorg risk\n  - *Delayed proving*: Wait for L1 finality (~15 minutes) before proving\n  - *Speculative proving*: Generate proofs speculatively, regenerate on reorg\n- **Multi-Prover Competition**: Based ZK-rollups like Taiko employ competitive proving markets where multiple provers race to submit proofs, with economic incentives for faster proof generation.\n\n### 2.5 State Derivation Architecture\n\nThe state derivation pipeline is the core mechanism by which based rollup nodes achieve consensus without explicit L2 coordination. This section addresses the detailed derivation process previously underspecified.\n\n#### 2.5.1 Derivation Pipeline Components\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 State Derivation Pipeline               \u2502\n\u2502                                                         \u2502\n\u2502  L1 Blocks \u2500\u2500\u25ba L1 Retrieval \u2500\u2500\u25ba Batch Decoding \u2500\u2500\u25ba     \u2502\n\u2502                                                         \u2502\n\u2502  \u2500\u2500\u25ba Deposit Processing \u2500\u2500\u25ba Transaction Ordering \u2500\u2500\u25ba   \u2502\n\u2502                                                         \u2502\n\u2502  \u2500\u2500\u25ba Execution \u2500\u2500\u25ba State Update \u2500\u2500\u25ba Head Management    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**L1 Retrieval**: Nodes fetch L1 blocks and extract:\n- Batch inbox transactions (calldata or blob references)\n- Deposit transactions from the L1 bridge contract\n- L1 block attributes (timestamp, basefee, hash)\n\n**Batch Decoding**: Compressed batch data is decoded into individual L2 transactions, with validation of batch format and sequencing rules.\n\n**Deposit Processing**: L1\u2192L2 deposits are processed with specific ordering guarantees:\n- Deposits are processed before user transactions within each L2 block\n- Deposit ordering follows L1 transaction ordering within the source block\n- Failed deposits are recorded but do not halt derivation\n\n#### 2.5.2 Transaction Ordering Rules\n\nThe derivation pipeline enforces deterministic ordering:\n\n```\nL2 Block N derived from L1 Block M:\n1. System deposit transactions (L1 attributes)\n2. User deposit transactions (L1\u2192L2 bridge calls, ordered by L1 tx index)\n3. Sequenced transactions (from batch data, ordered by batch position)\n```\n\n#### 2.5.3 Head Management and Reorg Handling\n\nBased rollups maintain multiple head references:\n\n- **Unsafe Head**: Latest derived L2 block from any L1 block (subject to L1 reorg)\n- **Safe Head**: L2 block derived from L1 blocks with sufficient confirmations (typically 64 blocks, ~13 minutes)\n- **Finalized Head**: L2 block derived from finalized L1 blocks (2 epochs, ~15 minutes)\n\n**Reorg Handling Protocol**:\n```\nOn L1 Reorg Detection:\n1. Identify common ancestor block between old and new L1 chain\n2. Revert L2 state to the L2 block derived from common ancestor\n3. Re-derive L2 state from new L1 chain\n4. Update unsafe/safe/finalized heads accordingly\n5. Notify connected clients of reorg depth\n```\n\nApplications should use the appropriate head based on their confirmation requirements:\n- DEX trades: Wait for safe head (13 minutes) or finalized head (15 minutes)\n- Low-value transactions: Unsafe head acceptable with reorg risk disclosure\n- Bridge withdrawals: Require finalized head\n\n---\n\n## 3. Security Properties\n\n### 3.1 Censorship Resistance\n\nBased rollups achieve strong censorship resistance properties, though the guarantees require careful qualification based on the relevant time horizon.\n\n#### 3.1.1 Long-term Censorship Resistance\n\nFor sustained censorship, based rollups inherit L1 guarantees:\n- With approximately 900,000 active validators on Ethereum (as of late 2024) distributed across thousands of independent operators, achieving sustained censorship requires coordinating a supermajority.\n- The economic cost of sustained censorship (controlling 33%+ of stake) exceeds $26 billion at current ETH prices.\n\n#### 3.1.2 Short-term Censorship Considerations\n\nShort-term censorship dynamics differ significantly due to builder centralization:\n\n**Builder Market Concentration** (Q4 2024 data):\n- Top 3 builders: ~80% of blocks\n- Top builder: ~40-50% of blocks\n- Top 5 builders: ~90% of blocks\n\nThis concentration means that for short time horizons (minutes to hours), a small number of builders could effectively censor L2 transactions without violating any protocol rules\u2014they simply choose not to include L2 batches in their blocks.\n\n**Mitigation Mechanisms**:\n1. **Inclusion Lists (EIP-7547)**: Proposers can mandate inclusion of specific transactions, limiting builder censorship power.\n2. **Builder Diversity Initiatives**: Protocol incentives for builder decentralization.\n3. **Direct Proposer Submission**: Fallback path bypassing builders for censored transactions.\n4. **Censorship Monitoring**: Real-time tracking of builder inclusion patterns.\n\n**Quantitative Censorship Analysis**:\n```\nProbability of N consecutive blocks without L2 inclusion:\n- If top 3 builders (80% share) collude: (0.80)^N\n- 10 blocks (~2 min): 10.7% probability\n- 50 blocks (~10 min): 0.14% probability\n- 100 blocks (~20 min): 0.0002% probability\n\nWith inclusion lists active:\n- Censorship limited to proposer-level (much more distributed)\n- Sustained censorship requires validator-level coordination\n```\n\n### 3.2 Liveness Guarantees\n\nLiveness in based rollups is directly inherited from L1, with important nuances:\n\n- **L1 Liveness \u2192 L2 Liveness**: If Ethereum continues producing blocks, based rollup transactions can be included.\n- **No Single Point of Failure**: Unlike centralized sequencers, no individual entity can halt the rollup.\n- **Degraded Mode Unnecessary**: Conventional rollups implement \"escape hatches\" allowing users to force-include transactions via L1 during sequencer failures. Based rollups obviate this mechanism since L1 inclusion is the default path.\n\n#### 3.2.1 Liveness Under Adversarial Conditions\n\nA critical question is what fraction of builders/proposers must be cooperative for timely L2 inclusion:\n\n**Builder-Level Analysis**:\n- If X% of builders are willing to include L2 batches, expected inclusion time = 12s / X%\n- With 20% cooperative builders: ~60 second expected inclusion\n- With 50% cooperative builders: ~24 second expected inclusion\n\n**Proposer-Level Analysis** (with inclusion lists):\n- Proposers are much more distributed than builders\n- Top 10 staking entities control ~50% of stake\n- Expected inclusion time with 50% cooperative proposers: ~24 seconds\n\nThe key insight is that based rollup liveness depends on builder cooperation under current PBS, but would depend on proposer cooperation with inclusion lists\u2014a much more favorable distribution.\n\n### 3.3 Reorg Resistance\n\nBased rollup security against reorganizations mirrors L1 properties:\n\n- **Pre-Finality**: L2 state is subject to reorganization if the corresponding L1 blocks are reorged.\n- **Post-Finality**: Once L1 blocks achieve finality (approximately 12-15 minutes under normal conditions), L2 state becomes immutable.\n\n**Confirmation Depth Recommendations**:\n| Use Case | Recommended Confirmation | Time | Reorg Probability |\n|----------|-------------------------|------|-------------------|\n| Low-value tx | 1 L1 block | 12s | ~0.1% |\n| Medium-value tx | 12 L1 blocks | 2.4 min | ~0.001% |\n| High-value tx | 32 L1 blocks | 6.4 min | <0.0001% |\n| Critical (bridges) | Finalized | ~15 min | 0% (absent consensus failure) |\n\n### 3.4 MEV and Transaction Ordering Fairness\n\nMEV dynamics in based rollups differ substantially from centralized alternatives, with important implications for user protection:\n\n| Property | Centralized Sequencer | Based Rollup |\n|----------|----------------------|--------------|\n| MEV Capture | Sequencer operator | L1 validators/builders |\n| Ordering Fairness | Operator-determined (can implement FCFS) | L1 PBS dynamics (auction-based) |\n| Cross-domain MEV | Limited | Native support |\n| User Protection | Operator policies (e.g., Arbitrum's fair ordering) | L1 mechanisms (MEV-Share, OFA) |\n| Sandwich Attack Exposure | Operator can prevent | Exposed to L1 MEV dynamics |\n\n#### 3.4.1 Transaction Ordering Fairness Analysis\n\nA critical consideration is that based rollups expose L2 users to L1 MEV extraction dynamics. Unlike centralized sequencers that can implement fair ordering policies (e.g., Arbitrum's first-come-first-served with time bounds), based rollups inherit the auction-based ordering of L1 PBS:\n\n**Implications**:\n- DEX trades on based rollups are subject to sandwich attacks by L1 searchers\n- Liquidations can be front-run by sophisticated MEV extractors\n- Users must use private mempools or MEV protection services\n\n**Mitigation Approaches**:\n1. **MEV-Share Integration**: Users can opt into MEV-Share to receive rebates from MEV extraction\n2. **Order Flow Auctions (OFA)**: Batch auctions that minimize extractable value\n3. **Encrypted Mempools**: Threshold encryption schemes that reveal transactions only at inclusion time\n4. **Application-Level Protection**: DEXs can implement MEV-resistant mechanisms (e.g., batch auctions, time-weighted pricing)\n\nWhether this MEV exposure is acceptable depends on the application: for applications where MEV extraction is minimal (simple transfers, NFT mints), based rollups provide strong guarantees; for high-MEV applications (DEX trading, liquidations), additional protection mechanisms may be necessary.\n\n---\n\n## 4. Comparative Analysis\n\n### 4.1 Quantitative Performance Comparison\n\nThis section provides rigorous quantitative comparisons across rollup architectures, addressing the need for empirical benchmarking.\n\n#### 4.1.1 Throughput Analysis\n\n| Metric | Based Rollup | Optimistic (Arbitrum) | ZK (zkSync Era) | Validium (StarkEx) |\n|--------|--------------|----------------------|-----------------|-------------------|\n| **Theoretical Max TPS** | ~100-500* | ~4,000 | ~2,000 | ~9,000 |\n| **Observed Peak TPS** | ~50 (Taiko) | ~62 (Arbitrum One) | ~110 (zkSync) | ~600 (dYdX) |\n| **Sustained TPS** | ~20-40 | ~15-40 | ~10-30 | ~100-200 |\n| **Bottleneck** | L1 blob space | Sequencer capacity | Prover throughput | DA committee |\n\n*Based rollup throughput is constrained by L1 blob space allocation:\n```\nBased Rollup Throughput Ceiling (EIP-4844):\n- Target blob space: 384 KB/block\n- Compressed tx size: ~50-100 bytes\n- Transactions per block: 3,840-7,680\n- TPS at 12s blocks: 320-640 theoretical max\n- Practical TPS (competition for blobs): 100-300\n```\n\n#### 4.1.2 Latency Distribution Analysis\n\n| Confirmation Type | Based Rollup | Centralized Sequencer | Shared Sequencer |\n|-------------------|--------------|----------------------|------------------|\n| **Soft Confirmation** | N/A (or preconf) | 250ms - 2s | 1-2s |\n| **L2 Block Inclusion** | 12s (L1 block) | 250ms - 2s | 1-2s |\n| **L1 Data Posted** | 12s | 1-10 min (batching) | 1-5 min |\n| **Safe (low reorg risk)** | ~13 min | ~13 min | ~13 min |\n| **Finalized** | ~15 min | ~15 min | ~15 min |\n\n**Latency Distribution Under Congestion**:\n```\nBased Rollup Inclusion Time (empirical, Taiko Q4 2024):\n- Median: 12 seconds (1 L1 block)\n- 90th percentile: 24 seconds (2 L1 blocks)\n- 99th percentile: 48 seconds (4 L1 blocks)\n- During blob congestion: up to 2-5 minutes\n\nCentralized Sequencer (Arbitrum, same period):\n- Median: 300ms\n- 90th percentile: 500ms\n- 99th percentile: 2s\n- During sequencer congestion: up to 30s\n```\n\n#### 4.1.3 Cost Structure Comparison\n\n| Cost Component | Based Rollup | Optimistic Rollup | ZK Rollup |\n|----------------|--------------|-------------------|-----------|\n| **L1 Data (per tx)** | $0.001-0.01 | $0.001-0.01 | $0.001-0.01 |\n| **L2 Execution** | $0.0001-0.001 | $0.0001-0.001 | $0.001-0.01 |\n| **Proof Cost** | N/A or amortized | N/A (fraud proof rare) | $0.01-0.10 amortized |\n| **Total (typical)** | $0.001-0.02 | $0.001-0.02 | $0.01-0.10 |\n\n### 4.2 Centralized Sequencers\n\nThe dominant model in production rollups employs a single sequencer operated by the rollup team:\n\n**Advantages**:\n- Sub-second soft confirmations\n- Predictable transaction ordering\n- MEV revenue for rollup sustainability\n- Simplified architecture\n- Ability to implement fair ordering policies\n\n**Disadvantages**:\n- Censorship vulnerability\n- Single point of failure\n- Trust requirements\n- Regulatory capture risk\n\n### 4.3 Decentralized Sequencer Networks\n\nProjects like Espresso Systems, Astria, and Radius propose shared sequencer networks:\n\n**Espresso Systems**: Implements a HotStuff-based consensus protocol among a permissioned validator set, offering fast finality with moderate decentralization. Targets ~1 second finality with ~100 node validator set.\n\n**Astria**: Provides a shared sequencing layer using CometBFT consensus, enabling multiple rollups to share sequencing infrastructure. Emphasizes rollup sovereignty with soft commitments.\n\n**Radius**: Focuses on encrypted mempools and threshold decryption to provide MEV protection alongside shared sequencing.\n\n**Detailed Comparison with Based Rollups**:\n\n| Criterion | Shared Sequencer | Based Rollup |\n|-----------|-----------------|--------------|\n| Decentralization | Moderate (10s-100s nodes) | High (1000s of validators) |\n| Confirmation Latency | ~1-2 seconds | ~12 seconds (L1 block time) |\n| Censorship Resistance | Moderate (sequencer set) | High (L1 validator set) |\n| Economic Complexity | New token/staking | Inherits ETH economics |\n| Cross-rollup Composability | Native (same sequencer) | Via L1 atomicity (limited) |\n| MEV Dynamics | Sequencer-determined | L1 PBS dynamics |\n| Liveness Dependency | Sequencer network | L1 liveness |\n| Security Assumptions | Sequencer honesty | L1 security |\n\n### 4.4 Cross-Rollup Composability Analysis\n\nCross-rollup composability represents a fundamental challenge for the L2 ecosystem, with different architectures offering distinct trade-offs.\n\n#### 4.4.1 Composability Limitations of Based Rollups\n\nBased rollups face inherent limitations for synchronous cross-rollup interactions:\n\n**Same-Block Limitation**: Even when two based rollups have transactions in the same L1 block, they cannot atomically interact because:\n1. Each rollup's state is derived independently\n2. No mechanism exists for one rollup's execution to depend on another's output within the same L1 block\n3. Cross-rollup calls would require the receiving rollup to process a message before its state is finalized\n\n**Implications for DeFi**:\n- **Atomic Arbitrage**: Cannot atomically arbitrage price differences between DEXs on different based rollups\n- **Cross-Rollup Liquidations**: Cannot atomically liquidate a position on Rollup A using collateral from Rollup B\n- **Multi-Venue Trading**: Cannot execute trades across multiple L2 DEXs in a single atomic transaction\n\n#### 4.4.2 Comparison with Shared Sequencer Approaches\n\nShared sequencer networks can offer superior cross-rollup properties:\n\n| Composability Type | Based Rollups | Shared Sequencer | Single Rollup |\n|-------------------|---------------|------------------|---------------|\n| Synchronous calls | \u274c | \u2705 (same sequencer) | \u2705 |\n| Atomic bundles | \u274c | \u2705 | \u2705 |\n| Asynchronous messages | \u2705 (via L1) | \u2705 | N/A",
  "manuscript_final_v3": "# Based Rollups: A Comprehensive Research Report on Ethereum-Native Sequencing for Layer 2 Scalability\n\n## Executive Summary\n\nBased rollups represent a paradigm shift in Layer 2 (L2) scaling architecture, fundamentally reconceptualizing the relationship between rollups and their underlying Layer 1 (L1) blockchain. Unlike conventional rollup designs that employ centralized or semi-decentralized sequencer networks, based rollups delegate transaction ordering directly to the L1 block proposers\u2014specifically, Ethereum validators in the context of Ethereum-based implementations.\n\nThis architectural decision carries profound implications for security, decentralization, liveness guarantees, and economic alignment within the broader blockchain ecosystem. By eliminating the need for dedicated sequencer infrastructure, based rollups inherit Ethereum's robust decentralization properties while simultaneously addressing critical concerns around censorship resistance and single points of failure that plague existing rollup implementations.\n\nThis report provides a comprehensive technical analysis of based rollups, examining their theoretical foundations, architectural components, economic implications, and practical implementations. We evaluate the trade-offs inherent in this design, compare based rollups against alternative sequencing mechanisms, and assess their potential to reshape the Layer 2 landscape. Our analysis draws upon recent academic literature, protocol specifications, and empirical data from early implementations to present a rigorous assessment of this emerging technology.\n\nKey findings indicate that based rollups offer superior decentralization and censorship resistance properties at the cost of reduced transaction confirmation latency and diminished MEV (Maximal Extractable Value) capture for L2 operators. The technology represents a compelling option for applications prioritizing security and Ethereum alignment over raw performance metrics. Critically, preconfirmation mechanisms\u2014where L1 proposers or restaked validators provide cryptoeconomically-secured soft commitments before L1 inclusion\u2014are emerging as essential complements that address the latency disadvantage while preserving based rollup security properties. Hybrid approaches incorporating these preconfirmation mechanisms may ultimately prove most practical for mainstream adoption. Significant challenges remain in preconfirmation standardization, cross-rollup composability, blob space contention dynamics, and sustainable economic models for L2 operators operating without MEV revenue.\n\n---\n\n## 1. Introduction\n\n### 1.1 The Rollup Scaling Paradigm\n\nEthereum's transition to a rollup-centric roadmap, formally articulated by Vitalik Buterin in 2020, positioned Layer 2 solutions as the primary mechanism for achieving scalable transaction throughput while preserving the security guarantees of the base layer. Rollups execute transactions off-chain while posting compressed transaction data or state commitments to Ethereum, thereby inheriting its security properties while dramatically reducing per-transaction costs.\n\nThe rollup ecosystem has bifurcated into several categories based on their proof mechanisms and data availability strategies:\n\n1. **Optimistic Rollups**: Assume transaction validity by default, employing fraud proofs during a challenge period (typically 7 days) to detect and penalize invalid state transitions. Prominent implementations include Optimism, Arbitrum, and Base.\n\n2. **Zero-Knowledge (ZK) Rollups**: Generate cryptographic validity proofs for each batch of transactions, enabling immediate finality upon proof verification. Notable examples include zkSync Era, StarkNet, Polygon zkEVM, and Scroll.\n\n3. **Validiums**: Store transaction data off-chain while posting validity proofs to L1, offering higher throughput at the cost of weaker data availability guarantees. The data is typically held by a Data Availability Committee (DAC) rather than posted to Ethereum. StarkEx operates in this mode for certain applications like dYdX (v3) and Immutable X.\n\n4. **Volitions**: Hybrid systems allowing users to choose between rollup mode (data on L1) and validium mode (data off-chain) on a per-transaction basis, enabling application-specific tradeoffs between security and cost. zkSync Era and StarkNet support volition modes.\n\nThe key distinction between rollups and validiums lies in data availability: rollups post all transaction data to L1 (enabling anyone to reconstruct state), while validiums rely on trusted committees or alternative DA layers. This creates a security-throughput spectrum that applications can navigate based on their requirements.\n\n### 1.2 The Sequencer Problem\n\nThe sequencer serves as the entity responsible for ordering transactions within a rollup, constructing blocks, and submitting batched data to the L1. In virtually all production rollup deployments as of 2024, sequencing is performed by a single, centralized operator\u2014typically the rollup development team itself.\n\nThis centralization introduces several concerning properties:\n\n- **Censorship Vulnerability**: A centralized sequencer can selectively exclude transactions, potentially for regulatory compliance, competitive advantage, or malicious purposes.\n- **Liveness Dependency**: Sequencer downtime results in complete rollup unavailability, as demonstrated by multiple incidents affecting Arbitrum and Optimism.\n- **MEV Extraction**: Centralized sequencers capture all MEV generated on the rollup, creating misaligned incentives and potential for user exploitation.\n- **Trust Assumptions**: Users must trust the sequencer to behave honestly, undermining the trustless ethos of blockchain systems.\n\n### 1.3 Defining Based Rollups\n\nThe term \"based rollup\" was formally introduced by Justin Drake of the Ethereum Foundation in March 2023, though the underlying concept had been discussed in various forms previously. Drake's definition provides the canonical characterization:\n\n> \"A rollup is said to be based, or L1-sequenced, when its sequencing is driven by the base L1. More concretely, a based rollup is one where the next L1 proposer may, in collaboration with L1 searchers and builders, permissionlessly include the next rollup block as part of the next L1 block.\"\n\nThis definition establishes three critical properties:\n\n1. **L1 Proposer Authority**: Ethereum validators (proposers) determine rollup block contents.\n2. **Permissionless Participation**: Any L1 proposer can sequence rollup transactions without special permissions.\n3. **Atomic Inclusion**: Rollup blocks are included atomically within L1 blocks.\n\n---\n\n## 2. Technical Architecture\n\n### 2.1 System Components\n\nA based rollup architecture comprises several interconnected components:\n\n#### 2.1.1 L1 Block Proposers and Builders\n\nUnder Ethereum's proof-of-stake consensus with Proposer-Builder Separation (PBS), validators are pseudo-randomly selected to propose blocks, while specialized builders construct block contents. In a based rollup system, builders gain the capability of incorporating rollup batches into their block construction, optimizing across both L1 and L2 transaction inclusion.\n\nThe distinction between proposers and builders is critical: under the MEV-Boost PBS architecture, proposers commit to block headers provided by builders through a relay system, without necessarily knowing the full block contents. This means based rollup batch inclusion occurs at the builder level, with proposers indirectly enabling L2 sequencing through their block commitments.\n\n#### 2.1.2 Based Rollup Nodes\n\nRollup nodes maintain the L2 state and provide transaction execution services. Unlike centralized sequencer architectures, based rollup nodes operate in a more egalitarian manner:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    L1 (Ethereum)                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  Builder 1  \u2502  \u2502  Builder 2  \u2502  \u2502  Builder N  \u2502     \u2502\n\u2502  \u2502 (constructs \u2502  \u2502 (constructs \u2502  \u2502 (constructs \u2502     \u2502\n\u2502  \u2502  L1+L2 txs) \u2502  \u2502  L1+L2 txs) \u2502  \u2502  L1+L2 txs) \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502         \u2502                \u2502                \u2502             \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502   Relay   \u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502 Proposer  \u2502                        \u2502\n\u2502                    \u2502(validator)\u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502 L1 Block  \u2502                        \u2502\n\u2502                    \u2502(+L2 Batch)\u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Based Rollup (L2)                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502   Node 1    \u2502  \u2502   Node 2    \u2502  \u2502   Node N    \u2502     \u2502\n\u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502     \u2502\n\u2502  \u2502   state)    \u2502  \u2502   state)    \u2502  \u2502   state)    \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n#### 2.1.3 Transaction Mempool\n\nBased rollups may utilize either a shared L1 mempool or maintain a separate L2 mempool that L1 builders can access. The mempool architecture significantly impacts MEV dynamics and transaction ordering guarantees. L2-specific mempools require builders to run additional infrastructure or integrate with L2 mempool aggregators, while shared mempools expose L2 transactions to L1 MEV extraction dynamics.\n\n#### 2.1.4 State Derivation Pipeline\n\nAll based rollup nodes derive the canonical L2 state by processing L1 blocks in order, extracting relevant rollup transactions, and executing them deterministically. This derivation process ensures consensus without requiring explicit L2 consensus mechanisms. The derivation pipeline must handle several critical functions detailed in Section 2.5.\n\n### 2.2 Block Production Mechanism\n\nThe block production process in a based rollup follows a distinct workflow:\n\n1. **Transaction Submission**: Users submit transactions to the L2 mempool or directly to L1 builders.\n\n2. **Builder Aggregation**: L1 block builders aggregate both L1 and L2 transactions, optimizing for total extractable value across both layers.\n\n3. **Relay Auction**: Builders submit block bids to relays, which verify block validity and forward winning bids to proposers.\n\n4. **Block Proposal**: The selected L1 proposer commits to a block header containing the L2 batch.\n\n5. **L1 Finalization**: The L1 block achieves finality through Ethereum's Gasper consensus mechanism (approximately 2 epochs, ~12-15 minutes).\n\n6. **L2 State Derivation**: Based rollup nodes process the L1 block, extract L2 transactions, and update the L2 state accordingly.\n\n### 2.3 Data Availability and EIP-4844 Integration\n\nBased rollups must post sufficient data to L1 to enable state reconstruction. With EIP-4844 (Proto-Danksharding), rollups can utilize blob transactions for more cost-effective data availability.\n\n#### 2.3.1 Blob Transaction Economics\n\nEIP-4844 introduces a separate fee market for blob data with distinct economic properties:\n\n- **Blob Gas Pricing**: Blob base fees adjust independently of execution gas, following an exponential mechanism targeting 3 blobs per block (384 KB) with a maximum of 6 blobs (768 KB).\n- **Price Volatility**: Blob fees can spike during high demand periods independently of L1 execution gas costs, requiring rollups to implement dynamic fee strategies.\n- **Cost Comparison**: At target utilization, blob data costs approximately 1-10 gwei per byte versus 16 gwei per byte for calldata, representing 10-100x cost reduction.\n\n```\nBlob Economics (EIP-4844):\n- Target: 3 blobs/block \u00d7 128 KB = 384 KB\n- Maximum: 6 blobs/block \u00d7 128 KB = 768 KB\n- Blob base fee adjustment: \u00b112.5% per block based on utilization\n- Current typical blob fee: 1-50 gwei per blob (highly variable)\n```\n\n#### 2.3.2 Blob Retention and Data Availability\n\nA critical consideration for based rollups is the blob retention window:\n\n- **Retention Period**: Blobs are guaranteed available for 4096 epochs (~18 days) before pruning.\n- **Implications for Optimistic Rollups**: The 7-day challenge period fits within the retention window, but rollups must ensure fraud proof submission occurs before blob pruning.\n- **Historical Reconstruction**: After blob pruning, rollups must maintain their own archival infrastructure or rely on third-party data availability providers (e.g., EthStorage, 0xBlobstore) for historical state reconstruction.\n- **Fallback Mechanisms**: Based rollups should implement calldata fallback when blob space is congested or blob fees spike above threshold levels.\n\n#### 2.3.3 Blob Space Contention and Multi-Rollup Dynamics\n\nA critical consideration underexplored in early based rollup analyses is the competitive dynamics when multiple rollups compete for limited blob space:\n\n**Contention Modeling**:\n```\nScenario: N based rollups competing for blob space\n- Available: 3 blobs/block (target), 6 blobs/block (max)\n- Per-rollup allocation at target: 3/N blobs/block\n\nWith 5 competing rollups:\n- Fair share: 0.6 blobs/block per rollup\n- Throughput per rollup: ~60-120 TPS (vs. 300-600 TPS solo)\n- Blob fee impact: Sustained above-target usage \u2192 exponential fee growth\n\nWith 10 competing rollups:\n- Fair share: 0.3 blobs/block per rollup\n- Throughput per rollup: ~30-60 TPS\n- Economic pressure: Smaller rollups priced out during congestion\n```\n\n**Game-Theoretic Considerations**:\n- **Blob Fee Bidding Wars**: During high-activity periods (NFT mints, airdrops), rollups must bid aggressively for blob inclusion, potentially pricing out smaller operators.\n- **Priority Fee Strategies**: Unlike centralized sequencers that can implement sophisticated blob fee management (e.g., batching during low-fee periods), based rollups have limited control over submission timing.\n- **Equilibrium Dynamics**: In steady state, blob fees should reflect the marginal value of L2 block space across all competing rollups, but transition dynamics can be volatile.\n\n**Observed Blob Fee Volatility** (Post-Dencun, Q2-Q4 2024):\n- Baseline: 1-10 gwei per blob\n- During inscriptions activity: 100-500 gwei per blob\n- Peak spikes: 1000+ gwei per blob (brief periods)\n- Impact on based rollup economics: 10-100x cost variation\n\n**Mitigation Strategies**:\n1. **Adaptive Batching**: Accumulate transactions during high-fee periods, submit larger batches when fees normalize\n2. **Calldata Fallback**: Switch to calldata posting when blob fees exceed threshold (e.g., >100 gwei)\n3. **Fee Smoothing**: Maintain fee reserves to absorb short-term spikes without passing costs to users\n4. **Blob Futures**: Emerging markets for blob space reservations (speculative)\n\n#### 2.3.4 Batch Submission Architecture\n\nBased rollup batches are submitted through the L1 builder pipeline rather than direct proposer submission:\n\n```solidity\n// Based rollup batch structure\nstruct RollupBatch {\n    bytes32 previousStateRoot;\n    bytes32 newStateRoot;\n    bytes32 withdrawalRoot;\n    uint64 l1BlockNumber;\n    bytes32 l1BlockHash;\n    uint64 l2BlockNumber;\n    bytes32 blobVersionedHash; // Reference to blob data\n}\n\n// Batch inbox contract with KZG verification\ncontract BatchInbox {\n    // Point evaluation precompile address (EIP-4844)\n    address constant POINT_EVALUATION_PRECOMPILE = 0x000000000000000000000000000000000000000A;\n    \n    event BatchAppended(\n        uint256 indexed batchIndex,\n        bytes32 indexed l1BlockHash,\n        bytes32 stateRoot,\n        address submitter\n    );\n    \n    // Mapping to track processed batches and prevent duplicates\n    mapping(bytes32 => bool) public processedBatches;\n    \n    function appendBatch(\n        RollupBatch calldata batch,\n        bytes calldata kzgCommitment,\n        bytes calldata kzgProof,\n        bytes32 evaluationPoint,\n        bytes32 claimedValue\n    ) external {\n        // Verify blob data availability via point evaluation precompile\n        // This proves that the blob with the given versioned hash contains\n        // the claimed data at the evaluation point\n        (bool success, bytes memory result) = POINT_EVALUATION_PRECOMPILE.staticcall(\n            abi.encodePacked(\n                batch.blobVersionedHash,\n                evaluationPoint,\n                claimedValue,\n                kzgCommitment,\n                kzgProof\n            )\n        );\n        require(success && result.length == 64, \"Blob verification failed\");\n        \n        // Verify L1 block reference is valid and recent\n        require(\n            batch.l1BlockHash == blockhash(batch.l1BlockNumber),\n            \"Invalid L1 reference\"\n        );\n        require(\n            block.number - batch.l1BlockNumber <= 256,\n            \"L1 reference too old\"\n        );\n        \n        // Prevent duplicate batch submission\n        bytes32 batchHash = keccak256(abi.encode(batch));\n        require(!processedBatches[batchHash], \"Batch already processed\");\n        processedBatches[batchHash] = true;\n        \n        // Note: No msg.sender restriction - permissionless submission\n        // Batch validity determined by derivation rules, not submitter identity\n        emit BatchAppended(nextBatchIndex++, batch.l1BlockHash, batch.newStateRoot, msg.sender);\n    }\n}\n```\n\nThe permissionless nature of batch submission is key: any party can submit batches, with validity determined by derivation rules rather than submitter identity. The KZG commitment verification ensures that the referenced blob data is actually available and contains the expected transaction data.\n\n**Builder-Rollup Coordination**: For builders to construct valid batches, they must:\n1. Run or connect to based rollup nodes to understand current L2 state\n2. Receive L2 transactions via dedicated mempool infrastructure or RPC endpoints\n3. Execute transactions against current state to determine validity and ordering\n4. Construct batches that conform to rollup derivation rules\n5. Include appropriate blob data with valid KZG commitments\n\nThis coordination overhead is a practical barrier to builder adoption, as builders must invest in L2-specific infrastructure for each based rollup they wish to support.\n\n### 2.4 Proof Systems\n\nBased rollups can employ either optimistic or validity proof systems, each with specific considerations for the based sequencing model:\n\n#### 2.4.1 Optimistic Based Rollups\n\nFraud proofs in optimistic based rollups face unique challenges:\n\n- **No Canonical Sequencer**: Without a centralized sequencer, fraud proofs challenge the derived state rather than sequencer commitments. The challenge target becomes the batch submitter's bond or a shared security pool.\n- **Derivation Disputes**: Fraud proofs must demonstrate that the claimed state root differs from the correctly derived state given the L1 block contents.\n- **Challenge Period Timing**: The 7-day challenge period must complete before blob data pruning (~18 days), providing adequate margin but requiring monitoring.\n\n```\nOptimistic Based Rollup Fraud Proof Flow:\n1. Batch submitted with state commitment S1\n2. Challenger claims correct state is S2 \u2260 S1\n3. Interactive dispute game bisects execution trace\n4. Single-step proof executed on L1\n5. Loser's bond slashed, winner compensated\n```\n\n#### 2.4.2 ZK Based Rollups\n\nValidity proof generation introduces timing considerations that interact with L1 finality in important ways:\n\n**Proof Generation Timing Reality**:\nCurrent ZK proving systems have the following characteristics:\n- **Taiko (SGX + ZK hybrid)**: SGX proofs in ~1-2 minutes, ZK proofs in 10-30 minutes\n- **zkSync Era**: Proof generation 5-15 minutes for typical batches\n- **Polygon zkEVM**: 10-30 minutes depending on batch complexity\n- **StarkNet**: STARK proofs in 5-20 minutes\n\nGiven that L1 finality occurs in ~15 minutes, most ZK provers complete proof generation *after* L1 finality for the blocks they're proving. This significantly simplifies the reorg concern:\n\n**Practical Proof Timing Strategies**:\n\n1. **Post-Finality Proving** (Most Common): Wait for L1 finality before generating proofs. This eliminates reorg risk entirely but adds ~15 minutes to the proof pipeline.\n\n2. **Speculative Proving with Checkpoints**: Begin proving immediately but checkpoint at L1 epoch boundaries. If reorg occurs, resume from last valid checkpoint rather than restarting entirely.\n\n3. **Proof Aggregation**: Aggregate proofs across multiple L2 blocks to amortize proving costs. A single proof covering 10-100 L2 blocks reduces per-block proving overhead.\n\n4. **Recursive Proving**: Use recursive proof composition to incrementally build proofs, allowing partial proof reuse even after reorgs.\n\n**Taiko's Multi-Tier Proving Architecture**:\nTaiko implements a particularly relevant model for based ZK-rollups:\n- **Tier 1 (SGX)**: Trusted execution environment provides fast (~minutes) attestations with lower security guarantees\n- **Tier 2 (ZK)**: Full validity proofs provide cryptographic security but take longer\n- **Economic Security**: SGX provers post bonds that can be slashed if their attestations are later contradicted by ZK proofs\n- **Competitive Proving**: Multiple provers can submit proofs, with the first valid proof earning rewards\n\n```\nTaiko Proving Timeline:\nL1 Block N contains L2 batch\n\u251c\u2500\u2500 T+0: L1 block published\n\u251c\u2500\u2500 T+1-2 min: SGX proof available (soft finality)\n\u251c\u2500\u2500 T+15 min: L1 finality achieved\n\u251c\u2500\u2500 T+15-45 min: ZK proof generated (hard finality)\n\u2514\u2500\u2500 T+45+ min: Proof verified on L1, state finalized\n```\n\n### 2.5 State Derivation Architecture\n\nThe state derivation pipeline is the core mechanism by which based rollup nodes achieve consensus without explicit L2 coordination. This section provides detailed specification of the derivation process.\n\n#### 2.5.1 Derivation Pipeline Components\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 State Derivation Pipeline               \u2502\n\u2502                                                         \u2502\n\u2502  L1 Blocks \u2500\u2500\u25ba L1 Retrieval \u2500\u2500\u25ba Batch Decoding \u2500\u2500\u25ba     \u2502\n\u2502                                                         \u2502\n\u2502  \u2500\u2500\u25ba Deposit Processing \u2500\u2500\u25ba Transaction Ordering \u2500\u2500\u25ba   \u2502\n\u2502                                                         \u2502\n\u2502  \u2500\u2500\u25ba Execution \u2500\u2500\u25ba State Update \u2500\u2500\u25ba Head Management    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**L1 Retrieval**: Nodes fetch L1 blocks and extract:\n- Batch inbox transactions (calldata or blob references)\n- Deposit transactions from the L1 bridge contract\n- L1 block attributes (timestamp, basefee, hash)\n\n**Batch Decoding**: Compressed batch data is decoded into individual L2 transactions, with validation of batch format and sequencing rules.\n\n**Deposit Processing**: L1\u2192L2 deposits are processed with specific ordering guarantees:\n- Deposits are processed before user transactions within each L2 block\n- Deposit ordering follows L1 transaction ordering within the source block\n- Failed deposits are recorded but do not halt derivation\n\n#### 2.5.2 Transaction Ordering Rules\n\nThe derivation pipeline enforces deterministic ordering:\n\n```\nL2 Block N derived from L1 Block M:\n1. System deposit transactions (L1 attributes)\n2. User deposit transactions (L1\u2192L2 bridge calls, ordered by L1 tx index)\n3. Sequenced transactions (from batch data, ordered by batch position)\n```\n\n#### 2.5.3 Batch Validity and Conflict Resolution\n\nA critical question for permissionless batch submission is handling conflicting or invalid batches:\n\n**Validity Conditions**:\n1. **Format Validity**: Batch data must decode to valid transactions according to rollup specification\n2. **State Transition Validity**: Executing transactions from `previousStateRoot` must yield `newStateRoot`\n3. **L1 Reference Validity**: Referenced L1 block must exist and be in the canonical chain\n4. **Ordering Validity**: Batch must reference the correct previous batch (no gaps or forks)\n\n**Conflict Resolution Protocol**:\nWhen multiple batches reference the same previous state:\n```\nConflict Resolution (Deterministic):\n1. Only the FIRST valid batch in L1 block ordering is canonical\n2. Subsequent conflicting batches are ignored by derivation\n3. \"First\" determined by: L1 block number \u2192 transaction index \u2192 log index\n\nExample:\n- L1 Block 1000, Tx 5: Batch A (previousRoot = X, newRoot = Y)\n- L1 Block 1000, Tx 8: Batch B (previousRoot = X, newRoot = Z)\n- Result: Batch A is canonical, Batch B is ignored\n```\n\n**Malformed Batch Handling**:\n```\nOn Invalid Batch Detection:\n1. If format invalid: Skip batch entirely, continue derivation\n2. If state transition invalid: \n   - Optimistic rollup: Accept batch, allow fraud proof challenge\n   - ZK rollup: Reject batch (no valid proof possible)\n3. If L1 reference invalid: Skip batch, continue derivation\n4. Log invalid batch for monitoring/alerting\n```\n\nThis deterministic conflict resolution ensures all honest nodes derive identical state without explicit coordination.\n\n#### 2.5.4 Head Management and Reorg Handling\n\nBased rollups maintain multiple head references:\n\n- **Unsafe Head**: Latest derived L2 block from any L1 block (subject to L1 reorg)\n- **Safe Head**: L2 block derived from L1 blocks with sufficient confirmations (typically 64 blocks, ~13 minutes)\n- **Finalized Head**: L2 block derived from finalized L1 blocks (2 epochs, ~15 minutes)\n\n**Reorg Handling Protocol**:\n```\nOn L1 Reorg Detection:\n1. Identify common ancestor block between old and new L1 chain\n2. Revert L2 state to the L2 block derived from common ancestor\n3. Re-derive L2 state from new L1 chain\n4. Update unsafe/safe/finalized heads accordingly\n5. Notify connected clients of reorg depth\n```\n\nApplications should use the appropriate head based on their confirmation requirements:\n- DEX trades: Wait for safe head (13 minutes) or finalized head (15 minutes)\n- Low-value transactions: Unsafe head acceptable with reorg risk disclosure\n- Bridge withdrawals: Require finalized head\n\n---\n\n## 3. Preconfirmation Mechanisms\n\nPreconfirmations represent the critical innovation enabling practical based rollup deployment by addressing the inherent latency disadvantage of L1-based sequencing. This section provides comprehensive analysis of preconfirmation protocols, their trust assumptions, and economic security models.\n\n### 3.1 The Preconfirmation Problem\n\nBased rollups face a fundamental latency challenge:\n- **Minimum confirmation time**: 12 seconds (one L1 block)\n- **Practical confirmation time**: 12-48 seconds (accounting for builder inclusion uncertainty)\n- **Competitor latency**: 250ms-2s for centralized sequencers\n\nFor many applications\u2014particularly DeFi trading, gaming, and real-time interactions\u2014this latency gap is prohibitive. Preconfirmations bridge this gap by providing faster soft commitments with varying security guarantees.\n\n### 3.2 Preconfirmation Architecture Spectrum\n\nPreconfirmation mechanisms exist on a spectrum from weak soft commitments to cryptoeconomically-secured guarantees:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Preconfirmation Security Spectrum                  \u2502\n\u2502                                                                 \u2502\n\u2502  Weak \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Strong\u2502\n\u2502                                                                 \u2502\n\u2502  Soft Hints    Reputation    Bonded Preconfs    L1 Inclusion   \u2502\n\u2502  (no guarantee) (social)     (slashable)        (final)        \u2502\n\u2502                                                                 \u2502\n\u2502  ~100ms        ~200ms        ~500ms-2s          12s+           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 3.3 Cryptoeconomic Preconfirmations\n\nThe most promising approach for based rollups involves cryptoeconomically-secured preconfirmations where providers post collateral that can be slashed for broken commitments.\n\n#### 3.3.1 Proposer-Based Preconfirmations\n\nL1 proposers can provide preconfirmations for their upcoming slots:\n\n**Mechanism**:\n1. Proposer is selected for slot N (known ~32 slots in advance via RANDAO)\n2. Proposer commits to including specific L2 transactions in their block\n3. Commitment is signed and published to preconfirmation network\n4. If proposer fails to include committed transactions, stake is slashed\n\n**Trust Assumptions**:\n- Users trust the preconfirmation network to deliver commitments\n- Users trust the slashing mechanism to execute correctly\n- Proposer has economic incentive to honor commitments (stake > MEV from reneging)\n\n**Limitations**:\n- Only proposers can provide preconfirmations for their slots\n- Lookahead is limited (~6 minutes with 32 slot visibility)\n- Proposer must be online and participating in preconf protocol\n\n#### 3.3.2 Restaking-Based Preconfirmations\n\nProtocols like Primev's mev-commit and EigenLayer-based solutions enable preconfirmations from restaked validators:\n\n**mev-commit Architecture**:\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    mev-commit Flow                      \u2502\n\u2502                                                         \u2502\n\u2502  User \u2500\u2500\u25ba Preconf Request \u2500\u2500\u25ba Provider Network         \u2502\n\u2502                                    \u2502                    \u2502\n\u2502                                    \u25bc                    \u2502\n\u2502                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502                            \u2502   Provider   \u2502            \u2502\n\u2502                            \u2502 (restaked)   \u2502            \u2502\n\u2502                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                                   \u2502                    \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502                    \u25bc              \u25bc              \u25bc     \u2502\n\u2502              Commitment     Relay to        Slashing  \u2502\n\u2502              Signature      Builder         Contract  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Economic Security Model**:\n- Providers stake ETH (native or restaked via EigenLayer)\n- Commitment to include transaction T by block B\n- If T not included by B: provider's stake slashed, user compensated\n- Slashing amount must exceed maximum MEV gain from reneging\n\n**Collateralization Requirements**:\n```\nMinimum Collateral = Max(Expected MEV, User Compensation) + Safety Margin\n\nExample for DEX trade:\n- Trade value: $10,000\n- Maximum slippage/MEV: 1% = $100\n- User compensation requirement: $100\n- Safety margin: 2x\n- Minimum provider collateral: $400 per preconfirmation\n\nProvider capacity = Total Stake / Collateral per Preconf\n- $1M stake, $400/preconf = 2,500 concurrent preconfs\n```\n\n#### 3.3.3 Bolt Protocol\n\nBolt (by Chainbound) represents a specific implementation of proposer commitments:\n\n**Key Features**:\n- Proposers register as Bolt operators and post additional collateral\n- Commitments are made via signed messages specifying transaction inclusion\n- Integration with MEV-Boost allows commitments to flow through existing PBS infrastructure\n- Slashing via smart contract if",
  "manuscript_v3": "# Based Rollups: A Comprehensive Research Report on Ethereum-Native Sequencing for Layer 2 Scalability\n\n## Executive Summary\n\nBased rollups represent a paradigm shift in Layer 2 (L2) scaling architecture, fundamentally reconceptualizing the relationship between rollups and their underlying Layer 1 (L1) blockchain. Unlike conventional rollup designs that employ centralized or semi-decentralized sequencer networks, based rollups delegate transaction ordering directly to the L1 block proposers\u2014specifically, Ethereum validators in the context of Ethereum-based implementations.\n\nThis architectural decision carries profound implications for security, decentralization, liveness guarantees, and economic alignment within the broader blockchain ecosystem. By eliminating the need for dedicated sequencer infrastructure, based rollups inherit Ethereum's robust decentralization properties while simultaneously addressing critical concerns around censorship resistance and single points of failure that plague existing rollup implementations.\n\nThis report provides a comprehensive technical analysis of based rollups, examining their theoretical foundations, architectural components, economic implications, and practical implementations. We evaluate the trade-offs inherent in this design, compare based rollups against alternative sequencing mechanisms, and assess their potential to reshape the Layer 2 landscape. Our analysis draws upon recent academic literature, protocol specifications, and empirical data from early implementations to present a rigorous assessment of this emerging technology.\n\nKey findings indicate that based rollups offer superior decentralization and censorship resistance properties at the cost of reduced transaction confirmation latency and diminished MEV (Maximal Extractable Value) capture for L2 operators. The technology represents a compelling option for applications prioritizing security and Ethereum alignment over raw performance metrics. Critically, preconfirmation mechanisms\u2014where L1 proposers or restaked validators provide cryptoeconomically-secured soft commitments before L1 inclusion\u2014are emerging as essential complements that address the latency disadvantage while preserving based rollup security properties. Hybrid approaches incorporating these preconfirmation mechanisms may ultimately prove most practical for mainstream adoption. Significant challenges remain in preconfirmation standardization, cross-rollup composability, blob space contention dynamics, and sustainable economic models for L2 operators operating without MEV revenue.\n\n---\n\n## 1. Introduction\n\n### 1.1 The Rollup Scaling Paradigm\n\nEthereum's transition to a rollup-centric roadmap, formally articulated by Vitalik Buterin in 2020, positioned Layer 2 solutions as the primary mechanism for achieving scalable transaction throughput while preserving the security guarantees of the base layer. Rollups execute transactions off-chain while posting compressed transaction data or state commitments to Ethereum, thereby inheriting its security properties while dramatically reducing per-transaction costs.\n\nThe rollup ecosystem has bifurcated into several categories based on their proof mechanisms and data availability strategies:\n\n1. **Optimistic Rollups**: Assume transaction validity by default, employing fraud proofs during a challenge period (typically 7 days) to detect and penalize invalid state transitions. Prominent implementations include Optimism, Arbitrum, and Base.\n\n2. **Zero-Knowledge (ZK) Rollups**: Generate cryptographic validity proofs for each batch of transactions, enabling immediate finality upon proof verification. Notable examples include zkSync Era, StarkNet, Polygon zkEVM, and Scroll.\n\n3. **Validiums**: Store transaction data off-chain while posting validity proofs to L1, offering higher throughput at the cost of weaker data availability guarantees. The data is typically held by a Data Availability Committee (DAC) rather than posted to Ethereum. StarkEx operates in this mode for certain applications like dYdX (v3) and Immutable X.\n\n4. **Volitions**: Hybrid systems allowing users to choose between rollup mode (data on L1) and validium mode (data off-chain) on a per-transaction basis, enabling application-specific tradeoffs between security and cost. zkSync Era and StarkNet support volition modes.\n\nThe key distinction between rollups and validiums lies in data availability: rollups post all transaction data to L1 (enabling anyone to reconstruct state), while validiums rely on trusted committees or alternative DA layers. This creates a security-throughput spectrum that applications can navigate based on their requirements.\n\n### 1.2 The Sequencer Problem\n\nThe sequencer serves as the entity responsible for ordering transactions within a rollup, constructing blocks, and submitting batched data to the L1. In virtually all production rollup deployments as of 2024, sequencing is performed by a single, centralized operator\u2014typically the rollup development team itself.\n\nThis centralization introduces several concerning properties:\n\n- **Censorship Vulnerability**: A centralized sequencer can selectively exclude transactions, potentially for regulatory compliance, competitive advantage, or malicious purposes.\n- **Liveness Dependency**: Sequencer downtime results in complete rollup unavailability, as demonstrated by multiple incidents affecting Arbitrum and Optimism.\n- **MEV Extraction**: Centralized sequencers capture all MEV generated on the rollup, creating misaligned incentives and potential for user exploitation.\n- **Trust Assumptions**: Users must trust the sequencer to behave honestly, undermining the trustless ethos of blockchain systems.\n\n### 1.3 Defining Based Rollups\n\nThe term \"based rollup\" was formally introduced by Justin Drake of the Ethereum Foundation in March 2023, though the underlying concept had been discussed in various forms previously. Drake's definition provides the canonical characterization:\n\n> \"A rollup is said to be based, or L1-sequenced, when its sequencing is driven by the base L1. More concretely, a based rollup is one where the next L1 proposer may, in collaboration with L1 searchers and builders, permissionlessly include the next rollup block as part of the next L1 block.\"\n\nThis definition establishes three critical properties:\n\n1. **L1 Proposer Authority**: Ethereum validators (proposers) determine rollup block contents.\n2. **Permissionless Participation**: Any L1 proposer can sequence rollup transactions without special permissions.\n3. **Atomic Inclusion**: Rollup blocks are included atomically within L1 blocks.\n\n---\n\n## 2. Technical Architecture\n\n### 2.1 System Components\n\nA based rollup architecture comprises several interconnected components:\n\n#### 2.1.1 L1 Block Proposers and Builders\n\nUnder Ethereum's proof-of-stake consensus with Proposer-Builder Separation (PBS), validators are pseudo-randomly selected to propose blocks, while specialized builders construct block contents. In a based rollup system, builders gain the capability of incorporating rollup batches into their block construction, optimizing across both L1 and L2 transaction inclusion.\n\nThe distinction between proposers and builders is critical: under the MEV-Boost PBS architecture, proposers commit to block headers provided by builders through a relay system, without necessarily knowing the full block contents. This means based rollup batch inclusion occurs at the builder level, with proposers indirectly enabling L2 sequencing through their block commitments.\n\n#### 2.1.2 Based Rollup Nodes\n\nRollup nodes maintain the L2 state and provide transaction execution services. Unlike centralized sequencer architectures, based rollup nodes operate in a more egalitarian manner:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    L1 (Ethereum)                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  Builder 1  \u2502  \u2502  Builder 2  \u2502  \u2502  Builder N  \u2502     \u2502\n\u2502  \u2502 (constructs \u2502  \u2502 (constructs \u2502  \u2502 (constructs \u2502     \u2502\n\u2502  \u2502  L1+L2 txs) \u2502  \u2502  L1+L2 txs) \u2502  \u2502  L1+L2 txs) \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502         \u2502                \u2502                \u2502             \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502   Relay   \u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502 Proposer  \u2502                        \u2502\n\u2502                    \u2502(validator)\u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                          \u25bc                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502 L1 Block  \u2502                        \u2502\n\u2502                    \u2502(+L2 Batch)\u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Based Rollup (L2)                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502   Node 1    \u2502  \u2502   Node 2    \u2502  \u2502   Node N    \u2502     \u2502\n\u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502     \u2502\n\u2502  \u2502   state)    \u2502  \u2502   state)    \u2502  \u2502   state)    \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n#### 2.1.3 Transaction Mempool\n\nBased rollups may utilize either a shared L1 mempool or maintain a separate L2 mempool that L1 builders can access. The mempool architecture significantly impacts MEV dynamics and transaction ordering guarantees. L2-specific mempools require builders to run additional infrastructure or integrate with L2 mempool aggregators, while shared mempools expose L2 transactions to L1 MEV extraction dynamics.\n\n#### 2.1.4 State Derivation Pipeline\n\nAll based rollup nodes derive the canonical L2 state by processing L1 blocks in order, extracting relevant rollup transactions, and executing them deterministically. This derivation process ensures consensus without requiring explicit L2 consensus mechanisms. The derivation pipeline must handle several critical functions detailed in Section 2.5.\n\n### 2.2 Block Production Mechanism\n\nThe block production process in a based rollup follows a distinct workflow:\n\n1. **Transaction Submission**: Users submit transactions to the L2 mempool or directly to L1 builders.\n\n2. **Builder Aggregation**: L1 block builders aggregate both L1 and L2 transactions, optimizing for total extractable value across both layers.\n\n3. **Relay Auction**: Builders submit block bids to relays, which verify block validity and forward winning bids to proposers.\n\n4. **Block Proposal**: The selected L1 proposer commits to a block header containing the L2 batch.\n\n5. **L1 Finalization**: The L1 block achieves finality through Ethereum's Gasper consensus mechanism (approximately 2 epochs, ~12-15 minutes).\n\n6. **L2 State Derivation**: Based rollup nodes process the L1 block, extract L2 transactions, and update the L2 state accordingly.\n\n### 2.3 Data Availability and EIP-4844 Integration\n\nBased rollups must post sufficient data to L1 to enable state reconstruction. With EIP-4844 (Proto-Danksharding), rollups can utilize blob transactions for more cost-effective data availability.\n\n#### 2.3.1 Blob Transaction Economics\n\nEIP-4844 introduces a separate fee market for blob data with distinct economic properties:\n\n- **Blob Gas Pricing**: Blob base fees adjust independently of execution gas, following an exponential mechanism targeting 3 blobs per block (384 KB) with a maximum of 6 blobs (768 KB).\n- **Price Volatility**: Blob fees can spike during high demand periods independently of L1 execution gas costs, requiring rollups to implement dynamic fee strategies.\n- **Cost Comparison**: At target utilization, blob data costs approximately 1-10 gwei per byte versus 16 gwei per byte for calldata, representing 10-100x cost reduction.\n\n```\nBlob Economics (EIP-4844):\n- Target: 3 blobs/block \u00d7 128 KB = 384 KB\n- Maximum: 6 blobs/block \u00d7 128 KB = 768 KB\n- Blob base fee adjustment: \u00b112.5% per block based on utilization\n- Current typical blob fee: 1-50 gwei per blob (highly variable)\n```\n\n#### 2.3.2 Blob Retention and Data Availability\n\nA critical consideration for based rollups is the blob retention window:\n\n- **Retention Period**: Blobs are guaranteed available for 4096 epochs (~18 days) before pruning.\n- **Implications for Optimistic Rollups**: The 7-day challenge period fits within the retention window, but rollups must ensure fraud proof submission occurs before blob pruning.\n- **Historical Reconstruction**: After blob pruning, rollups must maintain their own archival infrastructure or rely on third-party data availability providers (e.g., EthStorage, 0xBlobstore) for historical state reconstruction.\n- **Fallback Mechanisms**: Based rollups should implement calldata fallback when blob space is congested or blob fees spike above threshold levels.\n\n#### 2.3.3 Blob Space Contention and Multi-Rollup Dynamics\n\nA critical consideration underexplored in early based rollup analyses is the competitive dynamics when multiple rollups compete for limited blob space:\n\n**Contention Modeling**:\n```\nScenario: N based rollups competing for blob space\n- Available: 3 blobs/block (target), 6 blobs/block (max)\n- Per-rollup allocation at target: 3/N blobs/block\n\nWith 5 competing rollups:\n- Fair share: 0.6 blobs/block per rollup\n- Throughput per rollup: ~60-120 TPS (vs. 300-600 TPS solo)\n- Blob fee impact: Sustained above-target usage \u2192 exponential fee growth\n\nWith 10 competing rollups:\n- Fair share: 0.3 blobs/block per rollup\n- Throughput per rollup: ~30-60 TPS\n- Economic pressure: Smaller rollups priced out during congestion\n```\n\n**Game-Theoretic Considerations**:\n- **Blob Fee Bidding Wars**: During high-activity periods (NFT mints, airdrops), rollups must bid aggressively for blob inclusion, potentially pricing out smaller operators.\n- **Priority Fee Strategies**: Unlike centralized sequencers that can implement sophisticated blob fee management (e.g., batching during low-fee periods), based rollups have limited control over submission timing.\n- **Equilibrium Dynamics**: In steady state, blob fees should reflect the marginal value of L2 block space across all competing rollups, but transition dynamics can be volatile.\n\n**Observed Blob Fee Volatility** (Post-Dencun, Q2-Q4 2024):\n- Baseline: 1-10 gwei per blob\n- During inscriptions activity: 100-500 gwei per blob\n- Peak spikes: 1000+ gwei per blob (brief periods)\n- Impact on based rollup economics: 10-100x cost variation\n\n**Mitigation Strategies**:\n1. **Adaptive Batching**: Accumulate transactions during high-fee periods, submit larger batches when fees normalize\n2. **Calldata Fallback**: Switch to calldata posting when blob fees exceed threshold (e.g., >100 gwei)\n3. **Fee Smoothing**: Maintain fee reserves to absorb short-term spikes without passing costs to users\n4. **Blob Futures**: Emerging markets for blob space reservations (speculative)\n\n#### 2.3.4 Batch Submission Architecture\n\nBased rollup batches are submitted through the L1 builder pipeline rather than direct proposer submission:\n\n```solidity\n// Based rollup batch structure\nstruct RollupBatch {\n    bytes32 previousStateRoot;\n    bytes32 newStateRoot;\n    bytes32 withdrawalRoot;\n    uint64 l1BlockNumber;\n    bytes32 l1BlockHash;\n    uint64 l2BlockNumber;\n    bytes32 blobVersionedHash; // Reference to blob data\n}\n\n// Batch inbox contract with KZG verification\ncontract BatchInbox {\n    // Point evaluation precompile address (EIP-4844)\n    address constant POINT_EVALUATION_PRECOMPILE = 0x000000000000000000000000000000000000000A;\n    \n    event BatchAppended(\n        uint256 indexed batchIndex,\n        bytes32 indexed l1BlockHash,\n        bytes32 stateRoot,\n        address submitter\n    );\n    \n    // Mapping to track processed batches and prevent duplicates\n    mapping(bytes32 => bool) public processedBatches;\n    \n    function appendBatch(\n        RollupBatch calldata batch,\n        bytes calldata kzgCommitment,\n        bytes calldata kzgProof,\n        bytes32 evaluationPoint,\n        bytes32 claimedValue\n    ) external {\n        // Verify blob data availability via point evaluation precompile\n        // This proves that the blob with the given versioned hash contains\n        // the claimed data at the evaluation point\n        (bool success, bytes memory result) = POINT_EVALUATION_PRECOMPILE.staticcall(\n            abi.encodePacked(\n                batch.blobVersionedHash,\n                evaluationPoint,\n                claimedValue,\n                kzgCommitment,\n                kzgProof\n            )\n        );\n        require(success && result.length == 64, \"Blob verification failed\");\n        \n        // Verify L1 block reference is valid and recent\n        require(\n            batch.l1BlockHash == blockhash(batch.l1BlockNumber),\n            \"Invalid L1 reference\"\n        );\n        require(\n            block.number - batch.l1BlockNumber <= 256,\n            \"L1 reference too old\"\n        );\n        \n        // Prevent duplicate batch submission\n        bytes32 batchHash = keccak256(abi.encode(batch));\n        require(!processedBatches[batchHash], \"Batch already processed\");\n        processedBatches[batchHash] = true;\n        \n        // Note: No msg.sender restriction - permissionless submission\n        // Batch validity determined by derivation rules, not submitter identity\n        emit BatchAppended(nextBatchIndex++, batch.l1BlockHash, batch.newStateRoot, msg.sender);\n    }\n}\n```\n\nThe permissionless nature of batch submission is key: any party can submit batches, with validity determined by derivation rules rather than submitter identity. The KZG commitment verification ensures that the referenced blob data is actually available and contains the expected transaction data.\n\n**Builder-Rollup Coordination**: For builders to construct valid batches, they must:\n1. Run or connect to based rollup nodes to understand current L2 state\n2. Receive L2 transactions via dedicated mempool infrastructure or RPC endpoints\n3. Execute transactions against current state to determine validity and ordering\n4. Construct batches that conform to rollup derivation rules\n5. Include appropriate blob data with valid KZG commitments\n\nThis coordination overhead is a practical barrier to builder adoption, as builders must invest in L2-specific infrastructure for each based rollup they wish to support.\n\n### 2.4 Proof Systems\n\nBased rollups can employ either optimistic or validity proof systems, each with specific considerations for the based sequencing model:\n\n#### 2.4.1 Optimistic Based Rollups\n\nFraud proofs in optimistic based rollups face unique challenges:\n\n- **No Canonical Sequencer**: Without a centralized sequencer, fraud proofs challenge the derived state rather than sequencer commitments. The challenge target becomes the batch submitter's bond or a shared security pool.\n- **Derivation Disputes**: Fraud proofs must demonstrate that the claimed state root differs from the correctly derived state given the L1 block contents.\n- **Challenge Period Timing**: The 7-day challenge period must complete before blob data pruning (~18 days), providing adequate margin but requiring monitoring.\n\n```\nOptimistic Based Rollup Fraud Proof Flow:\n1. Batch submitted with state commitment S1\n2. Challenger claims correct state is S2 \u2260 S1\n3. Interactive dispute game bisects execution trace\n4. Single-step proof executed on L1\n5. Loser's bond slashed, winner compensated\n```\n\n#### 2.4.2 ZK Based Rollups\n\nValidity proof generation introduces timing considerations that interact with L1 finality in important ways:\n\n**Proof Generation Timing Reality**:\nCurrent ZK proving systems have the following characteristics:\n- **Taiko (SGX + ZK hybrid)**: SGX proofs in ~1-2 minutes, ZK proofs in 10-30 minutes\n- **zkSync Era**: Proof generation 5-15 minutes for typical batches\n- **Polygon zkEVM**: 10-30 minutes depending on batch complexity\n- **StarkNet**: STARK proofs in 5-20 minutes\n\nGiven that L1 finality occurs in ~15 minutes, most ZK provers complete proof generation *after* L1 finality for the blocks they're proving. This significantly simplifies the reorg concern:\n\n**Practical Proof Timing Strategies**:\n\n1. **Post-Finality Proving** (Most Common): Wait for L1 finality before generating proofs. This eliminates reorg risk entirely but adds ~15 minutes to the proof pipeline.\n\n2. **Speculative Proving with Checkpoints**: Begin proving immediately but checkpoint at L1 epoch boundaries. If reorg occurs, resume from last valid checkpoint rather than restarting entirely.\n\n3. **Proof Aggregation**: Aggregate proofs across multiple L2 blocks to amortize proving costs. A single proof covering 10-100 L2 blocks reduces per-block proving overhead.\n\n4. **Recursive Proving**: Use recursive proof composition to incrementally build proofs, allowing partial proof reuse even after reorgs.\n\n**Taiko's Multi-Tier Proving Architecture**:\nTaiko implements a particularly relevant model for based ZK-rollups:\n- **Tier 1 (SGX)**: Trusted execution environment provides fast (~minutes) attestations with lower security guarantees\n- **Tier 2 (ZK)**: Full validity proofs provide cryptographic security but take longer\n- **Economic Security**: SGX provers post bonds that can be slashed if their attestations are later contradicted by ZK proofs\n- **Competitive Proving**: Multiple provers can submit proofs, with the first valid proof earning rewards\n\n```\nTaiko Proving Timeline:\nL1 Block N contains L2 batch\n\u251c\u2500\u2500 T+0: L1 block published\n\u251c\u2500\u2500 T+1-2 min: SGX proof available (soft finality)\n\u251c\u2500\u2500 T+15 min: L1 finality achieved\n\u251c\u2500\u2500 T+15-45 min: ZK proof generated (hard finality)\n\u2514\u2500\u2500 T+45+ min: Proof verified on L1, state finalized\n```\n\n### 2.5 State Derivation Architecture\n\nThe state derivation pipeline is the core mechanism by which based rollup nodes achieve consensus without explicit L2 coordination. This section provides detailed specification of the derivation process.\n\n#### 2.5.1 Derivation Pipeline Components\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 State Derivation Pipeline               \u2502\n\u2502                                                         \u2502\n\u2502  L1 Blocks \u2500\u2500\u25ba L1 Retrieval \u2500\u2500\u25ba Batch Decoding \u2500\u2500\u25ba     \u2502\n\u2502                                                         \u2502\n\u2502  \u2500\u2500\u25ba Deposit Processing \u2500\u2500\u25ba Transaction Ordering \u2500\u2500\u25ba   \u2502\n\u2502                                                         \u2502\n\u2502  \u2500\u2500\u25ba Execution \u2500\u2500\u25ba State Update \u2500\u2500\u25ba Head Management    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**L1 Retrieval**: Nodes fetch L1 blocks and extract:\n- Batch inbox transactions (calldata or blob references)\n- Deposit transactions from the L1 bridge contract\n- L1 block attributes (timestamp, basefee, hash)\n\n**Batch Decoding**: Compressed batch data is decoded into individual L2 transactions, with validation of batch format and sequencing rules.\n\n**Deposit Processing**: L1\u2192L2 deposits are processed with specific ordering guarantees:\n- Deposits are processed before user transactions within each L2 block\n- Deposit ordering follows L1 transaction ordering within the source block\n- Failed deposits are recorded but do not halt derivation\n\n#### 2.5.2 Transaction Ordering Rules\n\nThe derivation pipeline enforces deterministic ordering:\n\n```\nL2 Block N derived from L1 Block M:\n1. System deposit transactions (L1 attributes)\n2. User deposit transactions (L1\u2192L2 bridge calls, ordered by L1 tx index)\n3. Sequenced transactions (from batch data, ordered by batch position)\n```\n\n#### 2.5.3 Batch Validity and Conflict Resolution\n\nA critical question for permissionless batch submission is handling conflicting or invalid batches:\n\n**Validity Conditions**:\n1. **Format Validity**: Batch data must decode to valid transactions according to rollup specification\n2. **State Transition Validity**: Executing transactions from `previousStateRoot` must yield `newStateRoot`\n3. **L1 Reference Validity**: Referenced L1 block must exist and be in the canonical chain\n4. **Ordering Validity**: Batch must reference the correct previous batch (no gaps or forks)\n\n**Conflict Resolution Protocol**:\nWhen multiple batches reference the same previous state:\n```\nConflict Resolution (Deterministic):\n1. Only the FIRST valid batch in L1 block ordering is canonical\n2. Subsequent conflicting batches are ignored by derivation\n3. \"First\" determined by: L1 block number \u2192 transaction index \u2192 log index\n\nExample:\n- L1 Block 1000, Tx 5: Batch A (previousRoot = X, newRoot = Y)\n- L1 Block 1000, Tx 8: Batch B (previousRoot = X, newRoot = Z)\n- Result: Batch A is canonical, Batch B is ignored\n```\n\n**Malformed Batch Handling**:\n```\nOn Invalid Batch Detection:\n1. If format invalid: Skip batch entirely, continue derivation\n2. If state transition invalid: \n   - Optimistic rollup: Accept batch, allow fraud proof challenge\n   - ZK rollup: Reject batch (no valid proof possible)\n3. If L1 reference invalid: Skip batch, continue derivation\n4. Log invalid batch for monitoring/alerting\n```\n\nThis deterministic conflict resolution ensures all honest nodes derive identical state without explicit coordination.\n\n#### 2.5.4 Head Management and Reorg Handling\n\nBased rollups maintain multiple head references:\n\n- **Unsafe Head**: Latest derived L2 block from any L1 block (subject to L1 reorg)\n- **Safe Head**: L2 block derived from L1 blocks with sufficient confirmations (typically 64 blocks, ~13 minutes)\n- **Finalized Head**: L2 block derived from finalized L1 blocks (2 epochs, ~15 minutes)\n\n**Reorg Handling Protocol**:\n```\nOn L1 Reorg Detection:\n1. Identify common ancestor block between old and new L1 chain\n2. Revert L2 state to the L2 block derived from common ancestor\n3. Re-derive L2 state from new L1 chain\n4. Update unsafe/safe/finalized heads accordingly\n5. Notify connected clients of reorg depth\n```\n\nApplications should use the appropriate head based on their confirmation requirements:\n- DEX trades: Wait for safe head (13 minutes) or finalized head (15 minutes)\n- Low-value transactions: Unsafe head acceptable with reorg risk disclosure\n- Bridge withdrawals: Require finalized head\n\n---\n\n## 3. Preconfirmation Mechanisms\n\nPreconfirmations represent the critical innovation enabling practical based rollup deployment by addressing the inherent latency disadvantage of L1-based sequencing. This section provides comprehensive analysis of preconfirmation protocols, their trust assumptions, and economic security models.\n\n### 3.1 The Preconfirmation Problem\n\nBased rollups face a fundamental latency challenge:\n- **Minimum confirmation time**: 12 seconds (one L1 block)\n- **Practical confirmation time**: 12-48 seconds (accounting for builder inclusion uncertainty)\n- **Competitor latency**: 250ms-2s for centralized sequencers\n\nFor many applications\u2014particularly DeFi trading, gaming, and real-time interactions\u2014this latency gap is prohibitive. Preconfirmations bridge this gap by providing faster soft commitments with varying security guarantees.\n\n### 3.2 Preconfirmation Architecture Spectrum\n\nPreconfirmation mechanisms exist on a spectrum from weak soft commitments to cryptoeconomically-secured guarantees:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Preconfirmation Security Spectrum                  \u2502\n\u2502                                                                 \u2502\n\u2502  Weak \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Strong\u2502\n\u2502                                                                 \u2502\n\u2502  Soft Hints    Reputation    Bonded Preconfs    L1 Inclusion   \u2502\n\u2502  (no guarantee) (social)     (slashable)        (final)        \u2502\n\u2502                                                                 \u2502\n\u2502  ~100ms        ~200ms        ~500ms-2s          12s+           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 3.3 Cryptoeconomic Preconfirmations\n\nThe most promising approach for based rollups involves cryptoeconomically-secured preconfirmations where providers post collateral that can be slashed for broken commitments.\n\n#### 3.3.1 Proposer-Based Preconfirmations\n\nL1 proposers can provide preconfirmations for their upcoming slots:\n\n**Mechanism**:\n1. Proposer is selected for slot N (known ~32 slots in advance via RANDAO)\n2. Proposer commits to including specific L2 transactions in their block\n3. Commitment is signed and published to preconfirmation network\n4. If proposer fails to include committed transactions, stake is slashed\n\n**Trust Assumptions**:\n- Users trust the preconfirmation network to deliver commitments\n- Users trust the slashing mechanism to execute correctly\n- Proposer has economic incentive to honor commitments (stake > MEV from reneging)\n\n**Limitations**:\n- Only proposers can provide preconfirmations for their slots\n- Lookahead is limited (~6 minutes with 32 slot visibility)\n- Proposer must be online and participating in preconf protocol\n\n#### 3.3.2 Restaking-Based Preconfirmations\n\nProtocols like Primev's mev-commit and EigenLayer-based solutions enable preconfirmations from restaked validators:\n\n**mev-commit Architecture**:\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    mev-commit Flow                      \u2502\n\u2502                                                         \u2502\n\u2502  User \u2500\u2500\u25ba Preconf Request \u2500\u2500\u25ba Provider Network         \u2502\n\u2502                                    \u2502                    \u2502\n\u2502                                    \u25bc                    \u2502\n\u2502                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502                            \u2502   Provider   \u2502            \u2502\n\u2502                            \u2502 (restaked)   \u2502            \u2502\n\u2502                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                                   \u2502                    \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502                    \u25bc              \u25bc              \u25bc     \u2502\n\u2502              Commitment     Relay to        Slashing  \u2502\n\u2502              Signature      Builder         Contract  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Economic Security Model**:\n- Providers stake ETH (native or restaked via EigenLayer)\n- Commitment to include transaction T by block B\n- If T not included by B: provider's stake slashed, user compensated\n- Slashing amount must exceed maximum MEV gain from reneging\n\n**Collateralization Requirements**:\n```\nMinimum Collateral = Max(Expected MEV, User Compensation) + Safety Margin\n\nExample for DEX trade:\n- Trade value: $10,000\n- Maximum slippage/MEV: 1% = $100\n- User compensation requirement: $100\n- Safety margin: 2x\n- Minimum provider collateral: $400 per preconfirmation\n\nProvider capacity = Total Stake / Collateral per Preconf\n- $1M stake, $400/preconf = 2,500 concurrent preconfs\n```\n\n#### 3.3.3 Bolt Protocol\n\nBolt (by Chainbound) represents a specific implementation of proposer commitments:\n\n**Key Features**:\n- Proposers register as Bolt operators and post additional collateral\n- Commitments are made via signed messages specifying transaction inclusion\n- Integration with MEV-Boost allows commitments to flow through existing PBS infrastructure\n- Slashing via smart contract if",
  "manuscript_v1": "# Based Rollups: A Comprehensive Research Report on Ethereum-Native Sequencing for Layer 2 Scalability\n\n## Executive Summary\n\nBased rollups represent a paradigm shift in Layer 2 (L2) scaling architecture, fundamentally reconceptualizing the relationship between rollups and their underlying Layer 1 (L1) blockchain. Unlike conventional rollup designs that employ centralized or semi-decentralized sequencer networks, based rollups delegate transaction ordering directly to the L1 block proposers\u2014specifically, Ethereum validators in the context of Ethereum-based implementations.\n\nThis architectural decision carries profound implications for security, decentralization, liveness guarantees, and economic alignment within the broader blockchain ecosystem. By eliminating the need for dedicated sequencer infrastructure, based rollups inherit Ethereum's robust decentralization properties while simultaneously addressing critical concerns around censorship resistance and single points of failure that plague existing rollup implementations.\n\nThis report provides a comprehensive technical analysis of based rollups, examining their theoretical foundations, architectural components, economic implications, and practical implementations. We evaluate the trade-offs inherent in this design, compare based rollups against alternative sequencing mechanisms, and assess their potential to reshape the Layer 2 landscape. Our analysis draws upon recent academic literature, protocol specifications, and empirical data from early implementations to present a rigorous assessment of this emerging technology.\n\nKey findings indicate that based rollups offer superior decentralization and censorship resistance properties at the cost of reduced transaction confirmation latency and diminished MEV (Maximal Extractable Value) capture for L2 operators. The technology represents a compelling option for applications prioritizing security and Ethereum alignment over raw performance metrics, though hybrid approaches may ultimately prove most practical for mainstream adoption.\n\n---\n\n## 1. Introduction\n\n### 1.1 The Rollup Scaling Paradigm\n\nEthereum's transition to a rollup-centric roadmap, formally articulated by Vitalik Buterin in 2020, positioned Layer 2 solutions as the primary mechanism for achieving scalable transaction throughput while preserving the security guarantees of the base layer. Rollups execute transactions off-chain while posting compressed transaction data or state commitments to Ethereum, thereby inheriting its security properties while dramatically reducing per-transaction costs.\n\nThe rollup ecosystem has bifurcated into two primary categories based on their fraud/validity proof mechanisms:\n\n1. **Optimistic Rollups**: Assume transaction validity by default, employing fraud proofs during a challenge period (typically 7 days) to detect and penalize invalid state transitions. Prominent implementations include Optimism, Arbitrum, and Base.\n\n2. **Zero-Knowledge (ZK) Rollups**: Generate cryptographic validity proofs for each batch of transactions, enabling immediate finality upon proof verification. Notable examples include zkSync Era, StarkNet, Polygon zkEVM, and Scroll.\n\nBoth categories, however, share a common architectural element that has emerged as a significant centralization vector: the sequencer.\n\n### 1.2 The Sequencer Problem\n\nThe sequencer serves as the entity responsible for ordering transactions within a rollup, constructing blocks, and submitting batched data to the L1. In virtually all production rollup deployments as of 2024, sequencing is performed by a single, centralized operator\u2014typically the rollup development team itself.\n\nThis centralization introduces several concerning properties:\n\n- **Censorship Vulnerability**: A centralized sequencer can selectively exclude transactions, potentially for regulatory compliance, competitive advantage, or malicious purposes.\n- **Liveness Dependency**: Sequencer downtime results in complete rollup unavailability, as demonstrated by multiple incidents affecting Arbitrum and Optimism.\n- **MEV Extraction**: Centralized sequencers capture all MEV generated on the rollup, creating misaligned incentives and potential for user exploitation.\n- **Trust Assumptions**: Users must trust the sequencer to behave honestly, undermining the trustless ethos of blockchain systems.\n\n### 1.3 Defining Based Rollups\n\nThe term \"based rollup\" was formally introduced by Justin Drake of the Ethereum Foundation in March 2023, though the underlying concept had been discussed in various forms previously. Drake's definition provides the canonical characterization:\n\n> \"A rollup is said to be based, or L1-sequenced, when its sequencing is driven by the base L1. More concretely, a based rollup is one where the next L1 proposer may, in collaboration with L1 searchers and builders, permissionlessly include the next rollup block as part of the next L1 block.\"\n\nThis definition establishes three critical properties:\n\n1. **L1 Proposer Authority**: Ethereum validators (proposers) determine rollup block contents.\n2. **Permissionless Participation**: Any L1 proposer can sequence rollup transactions without special permissions.\n3. **Atomic Inclusion**: Rollup blocks are included atomically within L1 blocks.\n\n---\n\n## 2. Technical Architecture\n\n### 2.1 System Components\n\nA based rollup architecture comprises several interconnected components:\n\n#### 2.1.1 L1 Block Proposers\n\nUnder Ethereum's proof-of-stake consensus, validators are pseudo-randomly selected to propose blocks. In a based rollup system, these proposers gain the additional capability of constructing rollup blocks. The proposer's role extends from merely ordering L1 transactions to orchestrating cross-layer transaction inclusion.\n\n#### 2.1.2 Based Rollup Nodes\n\nRollup nodes maintain the L2 state and provide transaction execution services. Unlike centralized sequencer architectures, based rollup nodes operate in a more egalitarian manner:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    L1 (Ethereum)                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Validator 1 \u2502  \u2502 Validator 2 \u2502  \u2502 Validator N \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502         \u2502                \u2502                \u2502             \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2502                          \u2502                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502  L1 Block \u2502                        \u2502\n\u2502                    \u2502  (+ L2    \u2502                        \u2502\n\u2502                    \u2502   Batch)  \u2502                        \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Based Rollup (L2)                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502   Node 1    \u2502  \u2502   Node 2    \u2502  \u2502   Node N    \u2502     \u2502\n\u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502  \u2502  (derives   \u2502     \u2502\n\u2502  \u2502   state)    \u2502  \u2502   state)    \u2502  \u2502   state)    \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n#### 2.1.3 Transaction Mempool\n\nBased rollups may utilize either a shared L1 mempool or maintain a separate L2 mempool that L1 builders can access. The mempool architecture significantly impacts MEV dynamics and transaction ordering guarantees.\n\n#### 2.1.4 State Derivation\n\nAll based rollup nodes derive the canonical L2 state by processing L1 blocks in order, extracting relevant rollup transactions, and executing them deterministically. This derivation process ensures consensus without requiring explicit L2 consensus mechanisms.\n\n### 2.2 Block Production Mechanism\n\nThe block production process in a based rollup follows a distinct workflow:\n\n1. **Transaction Submission**: Users submit transactions to the L2 mempool or directly to L1 builders.\n\n2. **Builder Aggregation**: L1 block builders (operating under Proposer-Builder Separation) aggregate both L1 and L2 transactions, optimizing for total extractable value.\n\n3. **Block Proposal**: The selected L1 proposer commits to a block containing the L2 batch.\n\n4. **L1 Finalization**: The L1 block achieves finality through Ethereum's consensus mechanism.\n\n5. **L2 State Derivation**: Based rollup nodes process the L1 block, extract L2 transactions, and update the L2 state accordingly.\n\n### 2.3 Data Availability and State Commitments\n\nBased rollups must post sufficient data to L1 to enable state reconstruction. This typically involves:\n\n```solidity\n// Simplified based rollup batch submission\nstruct RollupBatch {\n    bytes32 previousStateRoot;\n    bytes32 newStateRoot;\n    bytes compressedTransactions;\n    uint256 l1BlockNumber;\n    bytes32 l1BlockHash;\n}\n\nfunction submitBatch(RollupBatch calldata batch) external {\n    require(msg.sender == block.coinbase, \"Only L1 proposer\");\n    require(batch.l1BlockHash == blockhash(batch.l1BlockNumber), \"Invalid L1 reference\");\n    // Batch processing logic\n}\n```\n\nThe tight coupling with L1 block production enables atomic verification of batch validity relative to L1 state.\n\n### 2.4 Proof Systems\n\nBased rollups can employ either optimistic or validity proof systems:\n\n**Optimistic Based Rollups**: Fraud proofs reference L1 block data directly, simplifying the proving process since L1 state is inherently available.\n\n**ZK Based Rollups**: Validity proofs must be generated and verified, potentially introducing latency between batch submission and proof availability. Recent developments in proof aggregation and parallelization mitigate this concern.\n\n---\n\n## 3. Security Properties\n\n### 3.1 Censorship Resistance\n\nBased rollups achieve censorship resistance equivalent to the underlying L1. Since any Ethereum validator can include rollup transactions, censoring a specific transaction requires coordinating among a supermajority of validators\u2014the same threshold required to censor L1 transactions.\n\nQuantitatively, with approximately 900,000 active validators on Ethereum (as of late 2024) distributed across thousands of independent operators, achieving sustained censorship becomes economically and logistically prohibitive.\n\n### 3.2 Liveness Guarantees\n\nLiveness in based rollups is directly inherited from L1:\n\n- **L1 Liveness \u2192 L2 Liveness**: If Ethereum continues producing blocks, based rollup transactions can be included.\n- **No Single Point of Failure**: Unlike centralized sequencers, no individual entity can halt the rollup.\n- **Degraded Mode Unnecessary**: Conventional rollups implement \"escape hatches\" allowing users to force-include transactions via L1 during sequencer failures. Based rollups obviate this mechanism since L1 inclusion is the default path.\n\n### 3.3 Reorg Resistance\n\nBased rollup security against reorganizations mirrors L1 properties:\n\n- **Pre-Finality**: L2 state is subject to reorganization if the corresponding L1 blocks are reorged.\n- **Post-Finality**: Once L1 blocks achieve finality (approximately 12-15 minutes under normal conditions), L2 state becomes immutable.\n\nThis represents a trade-off compared to centralized sequencers, which can provide \"soft confirmations\" within seconds, albeit with weaker guarantees.\n\n### 3.4 MEV and Fair Ordering\n\nMEV dynamics in based rollups differ substantially from centralized alternatives:\n\n| Property | Centralized Sequencer | Based Rollup |\n|----------|----------------------|--------------|\n| MEV Capture | Sequencer operator | L1 validators/builders |\n| Ordering Fairness | Operator-determined | L1 PBS dynamics |\n| Cross-domain MEV | Limited | Native support |\n| User Protection | Operator policies | L1 mechanisms (e.g., MEV-Share) |\n\nThe shift of MEV to L1 validators has sparked debate regarding economic sustainability for L2 operators, addressed in Section 5.\n\n---\n\n## 4. Comparative Analysis\n\n### 4.1 Centralized Sequencers\n\nThe dominant model in production rollups employs a single sequencer operated by the rollup team:\n\n**Advantages**:\n- Sub-second soft confirmations\n- Predictable transaction ordering\n- MEV revenue for rollup sustainability\n- Simplified architecture\n\n**Disadvantages**:\n- Censorship vulnerability\n- Single point of failure\n- Trust requirements\n- Regulatory capture risk\n\n### 4.2 Decentralized Sequencer Networks\n\nProjects like Espresso Systems, Astria, and Radius propose shared sequencer networks:\n\n**Espresso Systems**: Implements a HotStuff-based consensus protocol among a permissioned validator set, offering fast finality with moderate decentralization.\n\n**Astria**: Provides a shared sequencing layer using CometBFT consensus, enabling multiple rollups to share sequencing infrastructure.\n\n**Radius**: Focuses on encrypted mempools and threshold decryption to provide MEV protection.\n\n**Comparison with Based Rollups**:\n\n| Criterion | Shared Sequencer | Based Rollup |\n|-----------|-----------------|--------------|\n| Decentralization | Moderate (10s-100s nodes) | High (1000s of validators) |\n| Confirmation Latency | ~1-2 seconds | ~12 seconds (L1 block time) |\n| Censorship Resistance | Moderate | High |\n| Economic Complexity | New token/staking | Inherits ETH economics |\n| Cross-rollup Composability | Native (same sequencer) | Via L1 atomicity |\n\n### 4.3 Hybrid Approaches\n\nEmerging designs combine based sequencing with optimistic fast confirmations:\n\n1. **Based Sequencing with Preconfirmations**: L1 proposers provide cryptographic commitments to include specific transactions, enabling fast soft confirmations while maintaining based properties.\n\n2. **Fallback Mechanisms**: Rollups operate with centralized sequencers during normal operation but fall back to based sequencing during censorship events.\n\n---\n\n## 5. Economic Considerations\n\n### 5.1 MEV Distribution\n\nThe most significant economic implication of based rollups concerns MEV redistribution. In centralized sequencer models, MEV accrues to the rollup operator, often constituting a substantial revenue stream. Based rollups redirect this value to L1 validators and builders.\n\nEmpirical data from L2 MEV research suggests:\n\n- Arbitrum generates approximately $1-5M monthly in MEV opportunities\n- Optimism MEV estimates range from $500K-2M monthly\n- Base (Coinbase's L2) captures significant MEV through its sequencer\n\nTransitioning to based sequencing would transfer these revenues to the Ethereum validator set, potentially:\n\n1. **Increasing L1 Security**: Higher validator rewards strengthen Ethereum's economic security.\n2. **Challenging L2 Business Models**: Rollup operators must find alternative revenue sources.\n3. **Aligning Incentives**: L1 validators become stakeholders in L2 success.\n\n### 5.2 Fee Structures\n\nBased rollups may implement modified fee structures to compensate for MEV loss:\n\n```\nTotal User Fee = Base Fee + Priority Fee + L1 Data Fee + Protocol Fee\n\nWhere:\n- Base Fee: Algorithmically adjusted based on L2 congestion\n- Priority Fee: Incentivizes inclusion priority\n- L1 Data Fee: Covers calldata/blob costs\n- Protocol Fee: Rollup operator revenue (new component)\n```\n\n### 5.3 Proposer-Builder Separation Implications\n\nBased rollups interact intimately with Ethereum's PBS architecture:\n\n- **Builder Integration**: L1 builders must incorporate L2 transaction bundles into their block construction algorithms.\n- **Cross-domain Bundle Auctions**: Sophisticated builders can optimize across L1 and L2 simultaneously.\n- **Relay Modifications**: Block relays may require updates to handle L2 batch commitments.\n\n### 5.4 Economic Security Analysis\n\nThe economic security of based rollups derives from Ethereum's staked ETH:\n\n- Total staked ETH: ~32 million ETH (~$80 billion at $2,500/ETH)\n- Cost to attack (33% threshold): ~$26 billion\n- Cost to attack (51% threshold): ~$40 billion\n\nThis security is inherited by based rollups without additional token issuance or staking requirements.\n\n---\n\n## 6. Implementation Landscape\n\n### 6.1 Taiko\n\nTaiko represents the most prominent based rollup implementation, launched on Ethereum mainnet in May 2024.\n\n**Technical Specifications**:\n- Type: Based ZK-rollup (Type 1 zkEVM)\n- Block Time: Aligned with Ethereum (~12 seconds)\n- Proving System: Multi-prover architecture supporting SGX, SP1, and Risc0\n- Data Availability: Ethereum calldata and EIP-4844 blobs\n\n**Architecture Highlights**:\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Taiko Protocol                       \u2502\n\u2502                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502  Proposers  \u2502  \u2502   Provers   \u2502  \u2502  Verifiers  \u2502     \u2502\n\u2502  \u2502 (L1 actors) \u2502  \u2502(competitive)\u2502  \u2502(L1 contract)\u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502         \u2502                \u2502                \u2502             \u2502\n\u2502         \u25bc                \u25bc                \u25bc             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502              TaikoL1 Contract                    \u2502   \u2502\n\u2502  \u2502  - Block proposal                                \u2502   \u2502\n\u2502  \u2502  - Proof verification                            \u2502   \u2502\n\u2502  \u2502  - State root management                         \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Performance Metrics** (as of Q4 2024):\n- Daily transactions: 50,000-200,000\n- Average gas costs: 30-50% lower than L1\n- Time to finality: Variable based on proving time\n\n### 6.2 Puffer UniFi\n\nPuffer Finance's UniFi represents a based rollup leveraging Puffer's restaking infrastructure:\n\n**Key Features**:\n- Integration with EigenLayer restaking\n- Native preconfirmations from Puffer validators\n- Shared security model across multiple rollups\n\n### 6.3 Spire (formerly Surge)\n\nSpire implements a based optimistic rollup with the following characteristics:\n\n- Optimistic fraud proof system\n- 7-day challenge period\n- Based sequencing with optional preconfirmations\n\n### 6.4 Research Implementations\n\nSeveral research-focused implementations explore based rollup design space:\n\n**OP Stack Based Mode**: Optimism's modular stack includes experimental based sequencing configurations.\n\n**Arbitrum Orbit**: Arbitrum's L3 framework theoretically supports based sequencing, though no production deployments exist.\n\n---\n\n## 7. Challenges and Limitations\n\n### 7.1 Latency Constraints\n\nThe most frequently cited limitation of based rollups is confirmation latency:\n\n- **L1 Block Time**: 12-second minimum confirmation time\n- **Slot Boundaries**: Transactions submitted mid-slot must wait for the next slot\n- **Comparison**: Centralized sequencers achieve sub-second confirmations\n\nThis latency impacts user experience for:\n- DEX trading (front-running windows)\n- Gaming applications\n- High-frequency interactions\n\n### 7.2 Preconfirmation Complexity\n\nPreconfirmations\u2014cryptographic commitments from future proposers to include specific transactions\u2014partially address latency concerns but introduce complexity:\n\n```\nPreconfirmation Flow:\n1. User requests preconfirmation for transaction T\n2. Current or upcoming proposer P signs commitment C\n3. User receives (T, C, P) as soft confirmation\n4. P must include T or face slashing\n\nChallenges:\n- Proposer lookahead limitations\n- Slashing mechanism design\n- Collateral requirements\n- Multi-proposer coordination\n```\n\n### 7.3 Builder Centralization\n\nEthereum's builder market exhibits significant centralization:\n\n- Top 3 builders: ~80% of blocks\n- Top builder (historically Flashbots): ~40-50% of blocks\n\nThis concentration potentially undermines based rollup censorship resistance, as a small number of builders could coordinate to exclude L2 transactions.\n\n**Mitigations**:\n- Inclusion lists (EIP-7547)\n- Builder diversity initiatives\n- Alternative block construction mechanisms\n\n### 7.4 Cross-L2 Composability\n\nWhile based rollups enable atomic L1-L2 composability, cross-L2 interactions remain challenging:\n\n- Different based rollups may have transactions in the same L1 block but cannot atomically interact\n- Synchronous composability requires additional coordination mechanisms\n- Shared sequencer networks potentially offer superior cross-L2 properties\n\n### 7.5 Economic Viability\n\nWithout MEV revenue, based rollup operators must develop sustainable business models:\n\n**Potential Revenue Sources**:\n1. Protocol fees on transactions\n2. Premium services (preconfirmations, priority inclusion)\n3. Ecosystem token value capture\n4. Infrastructure services (RPC, indexing)\n\n---\n\n## 8. Future Directions\n\n### 8.1 Preconfirmation Standardization\n\nThe Ethereum research community is actively developing preconfirmation standards:\n\n**EIP-7702 (Account Abstraction Extensions)**: Enables flexible transaction authorization potentially supporting preconfirmation delegation.\n\n**Based Preconfirmation Protocols**: Research into validator-issued preconfirmations with economic guarantees.\n\n**Timeline**: Production-ready preconfirmation systems expected 2025-2026.\n\n### 8.2 Integration with Ethereum Roadmap\n\nBased rollups align closely with Ethereum's development trajectory:\n\n**The Verge**: Verkle trees and stateless clients simplify L2 state verification.\n\n**The Purge**: Historical data pruning affects L2 data availability assumptions.\n\n**The Splurge**: Account abstraction and MEV mitigation directly impact based rollup UX.\n\n### 8.3 Multi-Prover Systems\n\nBased ZK-rollups benefit from multi-prover architectures:\n\n- Redundant proof generation increases security\n- Competitive proving markets reduce costs\n- Heterogeneous provers (TEE, ZK, MPC) provide defense-in-depth\n\n### 8.4 Interoperability Standards\n\nEmerging standards may enhance based rollup interoperability:\n\n- **Cross-L2 Message Passing**: Standardized formats for L2-to-L2 communication via L1\n- **Shared State Roots**: Aggregated state commitments enabling efficient cross-rollup verification\n- **Unified Bridge Contracts**: Common bridging infrastructure across based rollups\n\n### 8.5 Layer 3 and Beyond\n\nBased rollups may serve as foundations for L3 architectures:\n\n```\nL1 (Ethereum)\n    \u2502\n    \u251c\u2500\u2500 Based Rollup A (L2)\n    \u2502       \u251c\u2500\u2500 App-specific L3\n    \u2502       \u2514\u2500\u2500 Privacy L3\n    \u2502\n    \u2514\u2500\u2500 Based Rollup B (L2)\n            \u251c\u2500\u2500 Gaming L3\n            \u2514\u2500\u2500 DeFi L3\n```\n\n---\n\n## 9. Practical Implications\n\n### 9.1 For Protocol Developers\n\nTeams considering based rollup implementations should evaluate:\n\n1. **Latency Tolerance**: Applications requiring sub-second confirmations may need hybrid approaches.\n2. **MEV Sensitivity**: High-MEV applications (DEXs) require careful mechanism design.\n3. **Economic Sustainability**: Revenue models must account for MEV migration to L1.\n4. **Technical Complexity**: Integration with L1 PBS adds architectural complexity.\n\n### 9.2 For Application Developers\n\nApplications deployed on based rollups should consider:\n\n- **Confirmation Semantics**: Distinguish between L1 inclusion and L1 finality\n- **Reorg Handling**: Implement appropriate confirmation depth requirements\n- **Cross-Layer Interactions**: Leverage atomic L1-L2 composability where beneficial\n- **User Communication**: Set appropriate expectations for transaction confirmation times\n\n### 9.3 For Users\n\nEnd users interacting with based rollups should understand:\n\n- **Security Guarantees**: Equivalent to Ethereum L1 for finalized transactions\n- **Confirmation Times**: Longer than centralized alternatives but with stronger guarantees\n- **Cost Structures**: Potentially different fee dynamics than conventional rollups\n\n### 9.4 For Validators\n\nEthereum validators may benefit from based rollup adoption:\n\n- **Increased Revenue**: MEV from L2 transactions augments validator income\n- **Infrastructure Requirements**: May need to run L2 nodes for optimal MEV extraction\n- **Preconfirmation Opportunities**: Additional revenue from issuing preconfirmations\n\n---\n\n## 10. Conclusion\n\nBased rollups represent a philosophically pure approach to Layer 2 scaling, maximizing alignment with Ethereum's security and decentralization properties. By delegating sequencing to L1 proposers, based rollups eliminate the trust assumptions, censorship vulnerabilities, and single points of failure inherent in centralized sequencer architectures.\n\nThe trade-offs are significant but well-defined: increased confirmation latency, MEV redistribution to L1, and reliance on evolving preconfirmation mechanisms for improved user experience. These costs must be weighed against the substantial benefits of inherited security, permissionless operation, and native L1 composability.\n\nThe implementation landscape, led by Taiko and emerging projects like Puffer UniFi, demonstrates practical viability while highlighting areas requiring further development. Preconfirmation systems, in particular, represent a critical research frontier that will substantially impact based rollup competitiveness.\n\nLooking forward, based rollups appear well-positioned within Ethereum's roadmap, benefiting from planned upgrades to consensus mechanisms, data availability, and account abstraction. The technology may not suit all use cases\u2014latency-sensitive applications may prefer alternative sequencing mechanisms\u2014but for applications prioritizing security, decentralization, and Ethereum alignment, based rollups offer a compelling architectural choice.\n\nThe ultimate success of based rollups will depend on continued research into preconfirmations, sustainable economic models for operators, and the broader evolution of Ethereum's block production infrastructure. As the technology matures, we anticipate based rollups will occupy an important niche within the diverse L2 ecosystem, serving as the maximally Ethereum-aligned scaling solution for applications where security and censorship resistance are paramount.\n\n---\n\n## References\n\n1. Buterin, V. (2020). \"A rollup-centric Ethereum roadmap.\" Ethereum Magicians Forum.\n\n2. Drake, J. (2023). \"Based rollups\u2014superpowers from L1 sequencing.\" Ethereum Research.\n\n3. Ethereum Foundation. (2024). \"EIP-4844: Shard Blob Transactions.\" Ethereum Improvement Proposals.\n\n4. Taiko Labs. (2024). \"Taiko Protocol Specification.\" Technical Documentation.\n\n5. Flashbots. (2023). \"MEV-Boost: Merge ready Flashbots Architecture.\" GitHub Repository.\n\n6. Espresso Systems. (2024). \"Espresso Sequencer: Decentralized Sequencing for Rollups.\" Technical Whitepaper.\n\n7. Daian, P., et al. (2020). \"Flash Boys 2.0: Frontrunning in Decentralized Exchanges.\" IEEE S&P.\n\n8. Gudgeon, L., et al. (2020). \"SoK: Layer-Two Blockchain Protocols.\" Financial Cryptography.\n\n9. Thibault, L., et al. (2022). \"Blockchain Scaling Using Rollups.\" ACM Computing Surveys.\n\n10. Neu, J., et al. (2021). \"Ebb-and-Flow Protocols: A Resolution of the Availability-Finality Dilemma.\" IEEE S&P.\n\n---\n\n*Report prepared for academic and research purposes. Data and metrics current as of late 2024. Protocol specifications subject to change.*"
}